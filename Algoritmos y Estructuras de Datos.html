<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Algoritmos Resumen General</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1b9f3017-20ec-4d63-96d6-99fd95d9bcbd" class="page sans"><header><img class="page-cover-image" src="https://c.tenor.com/r9gRUQerG48AAAAd/vladimir-putin-putin.gif" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📚</span></div><h1 class="page-title">Algoritmos Resumen General</h1></header><div class="page-body"><p id="3719cac8-1f83-4585-b44b-8ab93c50729e" class="">
</p><h3 id="5a31728d-785f-4549-87c2-c57a9e3260c7" class="block-color-blue_background"> TEMA 1</h3><ul id="ecef1d7c-3280-4363-b99a-4f53b3d8cd83" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Costes</strong></summary><blockquote id="d41c5875-9456-4fa5-bbe3-87c816ea11ec" class="block-color-gray"><em>Costes Cola de Prioridad</em></blockquote><table id="a50289dd-d68d-4d2a-bc8e-87e39a207026" class="simple-table"><tbody><tr id="08ee5dc4-58aa-4b49-809a-b6768462ba23"><td id="OEoe">Cola de Prioridad</td><td id="Kh[\">Insertar</td><td id="tvLx">Eliminar Mínmo</td><td id="n:Tw">Consultar Mínimo</td></tr><tr id="194409d4-37ac-4a47-a1e6-335bc10a14cf"><td id="OEoe">vector no ordenado</td><td id="Kh[\">O(1)</td><td id="tvLx">O(n)</td><td id="n:Tw">O(1)</td></tr><tr id="e820ef15-44ba-49ac-b233-b7a3a7efb22e"><td id="OEoe">vector ordenado</td><td id="Kh[\">O(n)</td><td id="tvLx">O(1)</td><td id="n:Tw">O(1)</td></tr><tr id="b7ccbc62-3330-4f3e-9675-77fa20cae9bd"><td id="OEoe">lista enlazada no ordenada</td><td id="Kh[\">O(1)</td><td id="tvLx">O(n)</td><td id="n:Tw">O(1)</td></tr><tr id="61d3c086-65bd-4068-8b74-7da40679c2c5"><td id="OEoe">lista enlazada ordenada</td><td id="Kh[\">O(n)</td><td id="tvLx">O(1)</td><td id="n:Tw">O(1)</td></tr></tbody></table><blockquote id="1fce67ca-ab36-4c58-ae28-c9ebbf23d397" class="block-color-gray"><em>Costes Conjunto y Multi-Conjunto</em></blockquote><table id="0b5fae74-4813-4ce2-89df-ba5d5cc9fc6a" class="simple-table"><tbody><tr id="77353547-2bdd-4afd-8fb9-175ffb8e41b4"><td id="`Ou^">Conjunto</td><td id="|FZf">Insertar</td><td id="c^qv">Eliminar</td><td id="KcTd">Buscar</td></tr><tr id="8d89f536-6ba8-4782-91a8-8187979988c0"><td id="`Ou^">vector no ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(1)</td></tr><tr id="b8b2cb81-b4be-45d0-b243-577d623a6090"><td id="`Ou^">vector ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(log n)</td></tr><tr id="f1fee4a7-f1d3-40b9-848a-7000484d67d8"><td id="`Ou^">lista enlazada no ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr><tr id="b88ce96f-e857-48d5-a3e5-b3695816b61e"><td id="`Ou^">lista enlazada ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr></tbody></table><table id="7dad3cb1-376e-434a-bcfa-47c623c2b947" class="simple-table"><tbody><tr id="badc2e70-3601-4aeb-85a4-a0d4b05f1fd3"><td id="`Ou^">Multi-Conjunto</td><td id="|FZf">Insertar</td><td id="c^qv">Eliminar</td><td id="KcTd">Buscar</td></tr><tr id="16832cf5-a7e8-4496-8f10-be5bb9b3cced"><td id="`Ou^">vector no ordenado</td><td id="|FZf">O(1)</td><td id="c^qv">O(n)</td><td id="KcTd">O(1)</td></tr><tr id="a2909c40-37ee-4ce6-a0d1-35ee1191dfd9"><td id="`Ou^">vector ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(log n)</td></tr><tr id="fb0f0cd2-c539-4960-942a-5d9aabfaebdb"><td id="`Ou^">lista enlazada no ordenada</td><td id="|FZf">O(1)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr><tr id="157d3192-5c67-4878-b5d4-29e50133b52d"><td id="`Ou^">lista enlazada ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr></tbody></table><p id="a5a7fca9-193f-4b06-8201-724a4c815d84" class="">
</p><blockquote id="db3fee31-ccd9-45d6-ae6c-cd3cada03703" class="block-color-gray"><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA5.1/solucion_coste_temporal_Huffman.html"><em>Huffman implementado en varias estructuras de datos</em></a></blockquote><table id="8aab093f-1cc6-425d-8930-5e51e78612c2" class="simple-table"><tbody><tr id="8d9a7324-b869-4aa8-910c-f30c46ff8226"><td id="?ecC"></td><td id="W{[\">Inserción de N datos</td><td id="E[TW">Dos operaciones de eliminar mínimo N veces</td><td id="`_Nk">Una operación de inserción N veces</td></tr><tr id="49bbba3a-44f1-4642-a489-d1e71af1b5b6"><td id="?ecC">Vector no ordenado</td><td id="W{[\">O (n)</td><td id="E[TW">O (n)</td><td id="`_Nk">O (n^2)</td></tr><tr id="845c1216-a4b1-4884-bc7d-d38c35581f34"><td id="?ecC">Vector ordenado</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n)</td><td id="`_Nk">O (n^2)</td></tr><tr id="f8756f1c-1be4-4faf-8ca7-41abd05dda5d"><td id="?ecC">Árbol binario de búsqueda</td><td id="W{[\">O (n^2) </td><td id="E[TW">O (n^2)</td><td id="`_Nk">O (n^2)</td></tr><tr id="34199eb7-6594-404f-97c3-66c2f4cf2ef8"><td id="?ecC">Árbol de AVL</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr><tr id="4618a21b-1aca-46ea-8bdc-b79e8d7950fb"><td id="?ecC">Montículo binario</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr><tr id="07841dcb-a558-4031-90f1-202535e13b40"><td id="?ecC">Montículo de Fibonacci</td><td id="W{[\">O (n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr></tbody></table><p id="3f425ff9-b187-4e79-99ad-967c5aae56e1" class="">
</p><blockquote id="b036edf4-8100-41ae-99c6-ea99f201286a" class="block-color-gray"><em>Dijkstra y Prim </em><em><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/grafos.html#ejercicios6b">(Ejercicio 13 Tema 6.5)</a></em></blockquote><p id="1f4b4037-ecef-48bd-b8f8-11e0698c5789" class="">
</p></details></li></ul><h3 id="17ac309e-ffab-4e05-9b8c-fa66790d7a14" class="block-color-blue_background"> TEMA 2</h3><ul id="866fb524-f16d-4de6-8355-4f484f8f4f47" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Colas de Prioridad</strong></summary><blockquote id="96dd3169-cae3-4673-a8e4-ab962790421e" class="block-color-gray"><em>Estudia la implementación de la clase Cola y la clase Pila. Es importante entender lo que se ha hecho para conseguir los costes O(1) y en que se diferencia. Añade a la implementación de cola estos métodos:</em></blockquote><p id="6a17f066-2c1d-4917-9208-e18c58ddaaa7" class="block-color-blue">Buscar</p><pre id="4df96f44-69f8-493c-a439-07e9205f4b05" class="code"><code>// Buscar iterativo
bool Cola::buscar(int n) const {
    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente)
        if(actual-&gt;dato == n)
            return true;
    
    return false;
}

// Buscar recursivo
bool Cola::buscarRecursivo(int n, Nodo * actual) const {
    if (actual == nullptr)
        return false;

    if (actual-&gt;dato == n)
        return true;
    
    return buscarRecursivo(n, actual-&gt;siguiente);
}

bool Cola::buscarRecursivo(int n) const {
    buscarRecursivo(n, primero);
}</code></pre><p id="a3b3b418-b587-403d-9298-1bde00b0910f" class="block-color-blue">Buscar Posicion</p><pre id="fdfbd5d3-78f6-4f73-93e7-cf65581c3a4f" class="code"><code>// BuscarPosicion Iterativo
int Cola::buscarPosicion(int n) const {
    int posicion = 0;

    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente, posicion++)
        if(actual-&gt;dato == n)
            return posicion;

    return -1; 
}

//Buscar posiciones Recursivo
int Cola::buscarPosicionRecursivo(int n, Nodo * actual, int posicion) const{
    
    if(actual == nullptr)
        return -1;
    if(actual-&gt;dato == n)
        return posicion;
        
    return buscarPosicionRecursivo(n, actual-&gt;siguiente, posicion + 1);;
}

int Cola::buscarPosicionRecursivo(int n) const {   
    buscarPosicionRecursivo(n, primero, 0);
}</code></pre><p id="6d55fe4d-ec3f-471a-baa0-78591661418a" class="block-color-blue">Colas Iguales</p><pre id="72d5f033-08a5-4bc4-9f7c-1115eec170e7" class="code"><code>// ColasIguales Iterativo
bool Cola::colasIguales(const Cola &amp; cola) const {
    
    Nodo * actual = primero;
    Nodo * actualCola = cola.primero;

    while (actual != nullptr &amp;&amp; actualCola != nullptr) {
        if(actual-&gt;dato != actualCola-&gt;dato)
            return false;
        actual = actual-&gt;siguiente;
        actualCola = actualCola-&gt;siguiente;
    }

    return actual == nullptr &amp;&amp; actualCola == nullptr;
}

// ColasIguales Recursivo
bool Cola::colasIgualesRecursivo(Nodo * actual, Nodo * actualCola) const {

    if (actual == nullptr &amp;&amp; actualCola == nullptr)
        return true;
    
    if (actual == nullptr || actualCola == nullptr)
        return false;

    return actual-&gt;dato == actualCola-&gt;dato 
				&amp;&amp; colasIgualesRecursivo(actual-&gt;siguiente, actualCola-&gt;siguiente);
}

bool Cola::colasIgualesRecursivo(const Cola &amp; cola) const {
    colasIgualesRecursivo(primero, cola.primero);
}</code></pre><p id="15baa6d0-92e1-49bc-806d-a67f45b3acf7" class="block-color-blue">Eliminar</p><pre id="3b206303-611a-47fd-b85e-59391204bd6d" class="code"><code>// Eliminar Iterativo
void Cola::eliminar(int n) {
    if (primero == nullptr)
        throw string(&quot;Intentando eliminar un elemento de una cola vacía&quot;);
    
    Nodo * anterior = primero;
    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente) {
        if (actual-&gt;dato == n) {
            if (actual == ultimo)
                ultimo = anterior;
            if (actual == primero)
                primero = primero-&gt;siguiente;
            else
                anterior-&gt;siguiente = actual-&gt;siguiente;
            delete actual;
        }
        anterior = actual;
    }    
}

// Eliminar Recursivo
void Cola::eliminarRecursivo(int n, Nodo * &amp; actual, Nodo * anterior) {
    if (actual == nullptr)
        return;
    
    if(actual-&gt;dato == n) {
        Nodo * basura = actual;
        anterior-&gt;siguiente = actual-&gt;siguiente;
        delete basura;
        if (actual == nullptr)
            ultimo = anterior;
    }
    else 
        eliminarRecursivo(n, actual-&gt;siguiente, anterior);
}

void Cola::eliminarRecursivo(int n) {
    eliminarRecursivo(n, primero, primero);
}</code></pre></details></li></ul><ul id="23f7bf7b-2430-4a95-a5af-08f8f71d6eb1" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Lista doblemente enlazada</strong></summary><blockquote id="8ec68d42-3c8f-4301-afca-fc75397c3398" class="block-color-gray"><em>Una cola de prioridad de doble fin permite: insertar un elemento que tiene una cierta prioridad, extraer un elemento de minima prioridad y extraer un elemento de máxima prioridad. A estos hay que añadirles ciertos métodos que deben funcionar en los tiempos indicados:</em></blockquote><p id="a0bd76b3-7f94-4c29-af49-1062d54ca783" class="block-color-blue">Insertar</p><pre id="48bb595c-1935-464e-90b3-c496dd6cd46c" class="code"><code>// Insertar
void ColaDePrioridadDeDobleFin::insertar(int prioridad) {
    
    laTalla++;
    if (minimo == nullptr)
        minimo = maximo = new Nodo(prioridad, nullptr, nullptr);
    else if(prioridad &lt;= minimo-&gt;prioridad) {
        minimo = new Nodo(prioridad, nullptr, minimo);
        minimo-&gt;anterior-&gt;siguiente = minimo;
    } else if(prioridad &gt;= maximo-&gt;prioridad) {
        maximo = new Nodo(prioridad, maximo, nullptr);
        maximo-&gt;siguiente-&gt;anterior = nuevo;
    } else  {
        for(Nodo * actual = minimo; actual != nullptr, actual = actual -&gt;siguiente) {
            if(actual-&gt;dato == d) {
                Nodo * nuevo = new Nodo(prioridad, actual-&gt;anterior, actual)
                actual-&gt;anterior-&gt;siguiente = nuevo;
                actual-&gt;anterior = nuevo; 
                return;
            }
        }
    }
}</code></pre><p id="72775b1b-6d26-42a2-973a-a7411cb95359" class="block-color-blue">Eliminar</p><pre id="303dbc50-7610-4f44-8293-05d782310f45" class="code"><code>// Eliminar
void ColaDePrioridadDeDobleFin::eliminar(int prioridad) {
    for(Nodo * actual = minimo; actual != nullptr, actual = actual -&gt;siguiente) { 
        if (actual-&gt;prioridad == prioridad) {
            if(minimo == maximo)
                minimo = maximo = nullpter
            else if(prioridad == minimo-&gt;prioridad) {
                minimo = minimo-&gt;siguiente;
                minimo-&gt;anterior = nullptr;
            } else if (prioridad == maximo-&gt;prioridad) {
                maximo = maximo-&gt;anterior;
                minimo-&gt;siguiente = nullptr;
            } else {
                actual-&gt;anterior-&gt;siguiente = actual-&gt;siguiente;
                actual-&gt;siguiente-&gt;anterior = actual-&gt;anterior;
            }
            delete actual;
            laTalla--;
            return;
        }
    }
}</code></pre><p id="feac6119-6684-4e55-8828-58e25f6e6c84" class="block-color-blue">Vaciar</p><pre id="bc1878cf-61fa-457b-8245-21d7ddee6452" class="code"><code>// Vaciar
void ColaDePrioridadDeDobleFin::vaciar() const {
    Nodo * basura;
    while(minimo != nullptr) {
        basura = minimo;
        minimo = minimo-&gt;siguiente;
        delete basura;
    } 

    minimo = maximo = nullptr;
    laTalla = 0;
}</code></pre><p id="6a468f55-e2e8-4d84-9530-07af996e9e42" class="block-color-blue">Unir →O(a + b)</p><pre id="24634afa-5d4f-48a7-a496-6e9bcca227b0" class="code"><code>// Unir
void ColaDePrioridadDeDobleFin::unir(const ColaDeProiridadDeDobleFin &amp; cola1, const ColaDeProiridadDeDobleFin &amp; cola2) {
    Nodo * actualCola1 = cola1-&gt;primero;
    Nodo * actualCola2 = cola2-&gt;segundo;
    vaciar();
    laTalla = 0;

    while (actualCola1 != nullptr &amp;&amp; actualCola2 != nullptr) {
        if (actualCola1-&gt;priodidad &lt;= actualCola2-&gt;prioridad) {
            insertar(actualCola1-&gt;prioridad);
            actualCola1 = actualCola1-&gt;siguiente;
        }
        else {
            insertar(actualCola1-&gt;prioridad);
            actualCola2 = actualCola2-&gt;siguiente;
        }
        laTalla++;
    }

    while (actualCola1 != nullptr) {
        insertar(actualCola1-&gt;prioridad);
        actualCola1 = actualCola1-&gt;siguiente;
        laTalla++;
    }

    while (actualCola2 != nullptr) {
        insertar(actualCola2-&gt;prioridad);
        actualCola2 = actualCola2-&gt;siguiente;
        laTalla++;
    }
}</code></pre><p id="1e3756fe-4433-41a5-8f43-d500fc623ba8" class="">
</p></details></li></ul><h3 id="e944bf87-ab68-4e03-87a7-0498a3dfb600" class="block-color-blue_background"> TEMA 3</h3><ul id="75a658db-3624-43be-a317-9faec812cc92" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Árbol binario de búsqueda</strong></summary><blockquote id="2ff16b97-5adc-4b83-8513-2ca2e5b948dd" class=""><em>Partiendo de la versión inicial de la implementación del TAG Conjunto:</em></blockquote><p id="fa3e15ae-cb91-4fd1-8d00-9f9ea6ca5399" class="block-color-blue">Sumar</p><pre id="be22a81e-395a-417e-8885-9ea6f703d7d1" class="code"><code>
int Conjunto::sumar() const {
    return sumar(raiz);
}

int Conjunto::sumar(Nodo * actual) const {
    if (actual == nullptr)
        return 0;
    return actual-&gt;dato + sumar(actual-&gt;izquierdo) + sumar(actual-&gt;derecho);
}
</code></pre><p id="29729005-9179-430d-b2da-347915d65ec5" class="">
</p><p id="6e4b802b-e6e2-4eea-b0bf-3d61fa8ffb80" class="block-color-blue">Incrementar Todos</p><pre id="ac93d57e-7f1a-41da-aec1-38d35743679a" class="code"><code>void Conjunto::incrementarTodos() {
    incrementarTodos(raiz);
}

void Conjunto::incrementarTodos(Nodo * actual) {
    if (actual == nullptr)
        return;
    actual-&gt;dato++;
    incrementarTodos(actual-&gt;izquierdo);
    incrementarTodos(actual-&gt;derecho);
}</code></pre><p id="ad94c192-837a-46d3-b4fd-80db1ae8a187" class="">
</p><p id="38241b31-45de-4b88-a070-9381d5a85099" class="block-color-blue">Mostrar Ordenados</p><pre id="68d327c5-3663-43a1-b341-39026c753220" class="code"><code>void Conjunto::mostrarOrdenados() const {
    cout &lt;&lt; &quot;[&quot;;
    mostrarOrdenados(raiz);
    cout &lt;&lt; &quot;]&quot;;
}

void Conjunto::mostrarOrdenados(Nodo * actual) const {
    if (actual != nullptr) {
        mostrarOrdenados(actual-&gt;izquierdo);
        cout &lt;&lt; actual-&gt;dato &lt;&lt; &quot; &lt; &quot;;
        mostrarOrdenados(actual-&gt;derecho);
    }
}</code></pre><p id="566918f7-5a4b-4654-b40f-e4aa505cf9bb" class="">
</p><p id="80e90ca5-debe-4b49-8ce0-59d5a5e669db" class="block-color-blue">Obtener Ordenados</p><pre id="dced472e-068f-49cb-9e45-891da8b7ea15" class="code"><code>vector&lt;int&gt; Conjunto::obtenerOrdenados() const {
    vector&lt;int&gt; vectorOrdenados(laTalla);
    int i = 0;
    obtenerOrdenados(vectorOrdenados, raiz, i);
    return vectorOrdenados;
}

void Conjunto::obtenerOrdenados(vector&lt;int&gt; vectorOrdenados, Nodo * actual, int i) const {
    if (actual != nullptr) {
        obtenerOrdenados(vectorOrdenados, actual-&gt;izquierdo, i);
        vectorOrdenados[i++] = actual-&gt;dato;
        obtenerOrdenados(vectorOrdenados, actual-&gt;derecho, i);
    }
}</code></pre><p id="87f4c06a-356b-45e8-a31f-140575ba9614" class="">
</p><p id="08a0a7e1-8f28-4290-9f60-c333240c0455" class="block-color-blue">Buscar</p><pre id="d2de33f0-8783-463f-ac0e-e056822c427b" class="code"><code>bool Conjunto::buscar(int dato) const {
    return buscar(dato, raiz);
}

bool Conjunto::buscar(int dato, Nodo * actual) const {
    if (actual == nullptr)
        return false;
    if(actual-&gt;dato &gt; dato)
        buscar(dato, actual-&gt;izquierdo);
    if(actual-&gt;dato &lt; dato)
        buscar(dato, actual-&gt;derecho);

    return false;
}</code></pre><p id="8c4b3fcb-ee78-4959-b030-477de3d1b7f5" class="">
</p><p id="59d2d24d-cc4c-44fb-838b-f6eb91c2029a" class="block-color-blue">Insertar</p><pre id="f25276a9-055e-4aaa-bf53-0e22c3c99df3" class="code"><code>void Conjunto::insertar(int dato) {
    Nodo * actual = raiz;
    while (actual != nullptr) {
        if(dato == actual-&gt;dato) // No insertamos duplicados
            return; 
        else if(dato &lt; actual-&gt;dato)
            actual = actual-&gt;izquierdo;
        else
            actual = actual-&gt;derecho;
            
    }
    actual = new Nodo(dato);
    laTalla++;
}</code></pre><p id="4fb61196-5c7a-4dc6-9a24-5f066e1778f9" class="">
</p><p id="91e8f8f2-64e9-4414-b6d4-d4651cb1487b" class="block-color-blue">Vaciar</p><pre id="fcbce1ed-5b59-46dd-a60e-8d620434a293" class="code"><code>void Conjunto::vaciar() {
    vaciar(raiz);
    laTalla = 0;
    raiz = nullptr;
}

void Conjunto::vaciar(Nodo * actual) {
    if(actual != nullptr) {
        vaciar(actual-&gt;izquierdo);
        vaciar(actual-&gt;derecho);
        delete actual;
    }
}</code></pre><p id="148ac595-7523-4c27-88fb-53190a26fccc" class="">
</p><p id="19499116-9725-4f22-8559-3af84b711ce0" class="block-color-blue">Es Árbol Binario de Búsqueda</p><pre id="e498a118-2e54-48ff-b284-4ebee1f88805" class="code"><code>bool Conjunto::esArbolBinarioDeBusqueda() const {
    vector&lt;int&gt; vectorArbol(laTalla);
    int i = 0;
    obtenerOrdenados(vectorArbol, raiz, i);

    for (i = 1; i &lt; laTalla; i++)
        if (vectorArbol[i - 1] &gt; vectorArbol[i])
            return false;\
    return true;        
}</code></pre></details></li></ul><ul id="0bf42290-3086-4f5a-8aa1-8dd4d505f19b" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Diccionarios</strong></summary><blockquote id="565c9fba-a81e-4211-b725-e8cbebfadfdd" class="block-color-gray"><em>Esta implementación del TAD Diccionario permite almacenar datos de tipo entero con claves de tipo cadena, empleando internamente un árbol binario de búsqueda. Estos tres métodos son los mismos que teníamos en el TAD Conjunto pero modificados ligeramente para convertirlo en una implementación del TAD Diccionario que use internamente un árbol binario de búsqueda</em></blockquote><p id="ebf9fa13-afbd-45a1-b826-9f0f3c061464" class="block-color-blue">Insertar</p><pre id="9d8819cd-f956-435a-acd9-6043c9830fe5" class="code"><code>void Diccionario::insertar(const string &amp; unaClave, int unDato) {
    insertar(unaClave, unDato, raiz);
}

void Diccionario::insertar(const string &amp; unaClave, int unDato, Nodo * &amp; n) {
    if (n == nullptr) {
        n = new Nodo(unaClave, unDato);
        if (minimo == nullptr || unDato &lt; minimo-&gt;dato);
            minimo = n;
        laTalla++;
    }
    else if (unaClave &lt; n-&gt;clave)
        insertar(unaClave, unDato, n-&gt;izquierdo);
    else if (unaClave &gt; n-&gt;clave)
        insertar(unaClave, unDato, n-&gt;derecho);
    // No insertamos duplicados
}</code></pre><p id="0244311c-6a3a-45ab-95a2-8731958a407a" class="">
</p><p id="68669070-6415-4ea3-a372-8ea45dcc029d" class="block-color-blue">Eliminar</p><pre id="592e6bff-9f76-4b07-a167-d1cf6e0be087" class="code"><code>void Diccionario::eliminar(const string &amp; unaClave) {
    eliminar(unaClave, raiz);
}

void Diccionario::eliminar(const string &amp; unaClave, Nodo * &amp; n) {
    if (n == nullptr)
        return;
    if (unaClave &lt; n-&gt;clave)
        eliminar(unaClave, n-&gt;izquierdo);
    else if(unaClave &gt; n-&gt;clave)
        eliminar(unaClave, n-&gt;derecho);
    else if (n-&gt;izquierdo != nullptr &amp;&amp; n-&gt;derecho != nullptr) {
        Nodo * nodoMinimo = minimoEnSubarbol(n-&gt;derecho);
        n-&gt;dato = nodoMinimo-&gt;dato;
        n-&gt;clave = nodoMinimo-&gt;clave;
        eliminar(n-&gt;clave, n-&gt;derecho);
    } else {
        Nodo * basura = n;
        if (n-&gt;izquierdo != nullptr)
            n = n-&gt;izquierdo;
        else 
            n = n-&gt;derecho;
        if (basura == minimo)
            if (raiz != nullptr)
                minimo = minimoEnSubarbol(raiz);
            else 
                minimo = nullptr;
        delete basura;
        laTalla--;
    }
}</code></pre><p id="9b9ee6b6-8db8-4a6a-8900-792a85afe29c" class="">
</p><p id="c48718d0-57b9-44cd-96f7-e0d58fb55c15" class="block-color-blue">Buscar</p><pre id="c271099c-e06f-4d49-a5af-ec1ad5db3050" class="code"><code>int &amp;  Diccionario::buscar(const string &amp; unaClave) const {
    return buscar(unaClave, raiz);
}

int &amp;  Diccionario::buscar(const string &amp; unaClave, Nodo * actual) const {
    if (actual == nullptr)
        throw string(&quot;No existe ningun elemento en el diccionario con la clave buscada.&quot;);
    if (unaClave &lt; actual-&gt;clave)
        buscar(unaClave, actual-&gt;izquierdo);
    if (unaClave &gt; actual-&gt;clave)
        buscar(unaClave, actual-&gt;derecho);
    return actual-&gt;dato;
}</code></pre></details></li></ul><ul id="7d004dcb-5ddc-47d2-b0dd-70e8ff45fea7" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Métodos árboles</strong></summary><p id="de4f8f4b-d482-4606-900b-b1102b77d9a3" class="block-color-blue">Altura Arbol</p><pre id="e81b8c5c-9ae5-4202-8f81-eff301a7dcb5" class="code"><code>int Conjunto::altura() const {
    return altura(raiz);
}

int Conjunto::altura(Nodo * actual) const {
    if (actual == nullptr)
        return -1;
    return 1 + max(altura(actual-&gt;izquierdo), altura(actual-&gt;derecho));
}</code></pre><p id="4ed6f76a-d20f-45fb-873f-51cda65a80f0" class="block-color-blue">No Hay Hijo Sin Hermano</p><pre id="d1e174c0-b56f-42cd-a5b7-f0538403939b" class="code"><code>bool Conjunto::noHayHijoSinHermano() const {
    return raiz == nullptr || noHayHijoSinHermano(raiz);
}

bool Conjunto::noHayHijoSinHermano(Nodo * actual) const {
    if(actual-&gt;izquierdo == nullptr &amp;&amp; actual-&gt;derecho == nullptr)
        return true;
    if(actual-&gt;izquierdo != nullptr &amp;&amp; actual-&gt;derecho != nullptr)
        return noHayHijoSinHermano(actual-&gt;izquierdo) &amp;&amp; noHayHijoSinHermano(actual-&gt;derecho);
    return false;
}</code></pre><blockquote id="87184829-64a0-45b2-a099-594f3e40b7c3" class="">S<em>e hace especial énfasis en la forma en la que la recursividad puede solucionar estos problemas de manera eficiente</em></blockquote><p id="570411f2-240a-444d-b0f7-e87da51c5411" class="block-color-blue">Arboles Iguales</p><pre id="6bf1e62c-218b-4859-8935-c4f8bdbac83e" class="code"><code>bool Conjunto::arbolesIguales(const Conjunto &amp; otroConjunto) const {
    return arbolesIguales(raiz, otroConjunto.raiz);
}

bool Conjunto::arbolesIguales(Nodo * n1, Nodo * n2) const {

    if (n1 == nullptr &amp;&amp; n2 == nullptr)
        return true;
    if (n1 != nullptr || n2 != nullptr)
        return false;
    if (n1-&gt;dato != n2-&gt;dato)
        return false;
    return arbolesIguales(n1-&gt;izquierdo, n2-&gt;izquierdo)
            &amp;&amp; arbolesIguales(n1-&gt;derecho, n2-&gt;derecho);    
}</code></pre><blockquote id="56652746-e9a2-4888-8a2f-9f1912559699" class=""><em>Este ejercicio es una introducción básica a una manera en la que se pueden recorrer los árboles en anchura. Esta estrategia se repetirá en algunos ejercicios del tema de grafos.</em></blockquote><p id="da2ba3bd-8d84-4adb-8b14-57252520b202" class="block-color-blue">Mostrar Por Nivel</p><pre id="dd07cf30-303c-4ec5-833a-13728abfcb76" class="code"><code>void Conjunto::mostrarPorNiveles() const {
    queue&lt;Nodo *&gt; nodosAMostrar;

    if (raiz != nullptr) {
        nodosAMostrar.push(raiz);
        int nivel = 1;
        mostrarPorNiveles(nodosAMostrar);
    }
}

void Conjunto::mostrarPorNiveles(queue&lt;Nodo *&gt; nodosAMostrar) const {
    if (!nodosAMostrar.empty()) {
        Nodo * actual = nodosAMostrar.front();
        cout &lt;&lt; &quot;Dato: &quot; &lt;&lt; actual &lt;&lt; endl;
        nodosAMostrar.pop();
        if(actual-&gt;izquierdo != nullptr)
            nodosAMostrar.push(actual-&gt;izquierdo);
        if(actual-&gt;derecho != nullptr)
            nodosAMostrar.push(actual-&gt;derecho);
        mostrarPorNiveles(nodosAMostrar);
    }
}</code></pre><blockquote id="9caabde0-3e46-4dc4-b306-8661e366e8c3" class=""><em>Estructura completa de la manera correcta de recorrer un árbol por niveles. Hay </em><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA3/Conjunto_verificarProfundidad.html"><em>varias formas</em></a><em> de solucionar este ejercicio: con la implementación de un struct Pair donde se guardara la profundidad del nodo, usando una cola y manteniendo un contador de la talla de cada nivel, una pila de pares...</em></blockquote><p id="08aa2019-dce6-4fa0-8fc3-079d1428d675" class="block-color-blue">Verificar Profundidad</p><pre id="d77b00ab-6210-4d62-bdf7-98bd396b15d6" class="code"><code>// Verificar Profundidad Recursivo
bool Conjunto::verificarProfundidadR(int profundidad) const {
    verificarProfundidadR(raiz, profundidad);
}

bool Conjunto::verificarProfundidadR(Nodo * actual, int profundidad) const {
    if (actual == nullptr)
        return false;
    
    if (profundidad == 0)
        return true;
    
    return verificarProfundidadR(actual-&gt;izquierdo, profundidad - 1) 
        ||  verificarProfundidadR(actual-&gt;derecho, profundidad - 1);
}

// Verificar Profundidad Iterativo
bool Conjunto::verificarProfundidad(int profundidad) const {
    if (raiz == nullptr)
        return;

    if (profundidad == 0)
        return;

    queue&lt;Nodo *&gt; cola;
    cola.push(raiz);
    int tallaPorNivel = cola.size();

    while(!cola.empty()) {     
        Nodo * n = cola.front();
        cola.pop();

        if (n-&gt;izquierdo != nullptr) {
            if (profundidad == 0)
                return true;
            cola.push(n-&gt;izquierdo);
        }
        if (n-&gt;derecho != nullptr) {
            if (profundidad == 0)
                    return true;
            cola.push(n-&gt;derecho);
        }

        if (--tallaPorNivel == 0) {
            tallaPorNivel = cola.size();
            profundidad -= 1;
        }
    }

    return false;
}</code></pre></details></li></ul><ul id="0c1986eb-ba8e-49e1-97da-99fa8a9b059f" class="block-color-gray_background toggle"><li><details open=""><summary><strong>AVL</strong></summary><p id="f8cca665-b32c-4542-9041-a9ce4989a7f7" class="">
</p></details></li></ul><h3 id="742247c6-f0f6-4329-935f-648cb7e914da" class="block-color-blue_background"> TEMA 4</h3><ul id="fb90062e-f29e-4d7f-ac6a-2380226d7380" class="block-color-gray_background toggle"><li><details open=""><summary>Huffman</summary><blockquote id="21097456-80bb-4f46-97c3-0292d0bb7245" class="block-color-gray"><em>Implementar el constructor de la clase Huffman y métodos para codificar y decodificar. </em><strong><a href="https://es.wikipedia.org/wiki/Algoritmo_de_Huffman#Descripci.C3.B3n"><em>Explicación</em></a></strong></blockquote><blockquote id="3beab4b6-b00d-40d6-ba34-e48193d69f44" class="block-color-gray"><em>Los costes en el algoritmo de Huffman van a depender de la estructura interna con que decidamos implementarlo: vector ordenado, AVL, montículo binario...</em></blockquote><p id="7028473e-12f6-489f-9eb1-f98bdc9023e3" class="block-color-blue">Constructor</p><pre id="448e22d9-1e0a-48b4-b9b8-1ba71269c2ea" class="code"><code>Huffman::Huffman(const vector&lt;pair&lt;char, float&gt;&gt; &amp; frecuencias) : raiz{nullptr} {

    if (frecuencias.size() &lt; 2)
        throw string(&quot;Necesitamos al menos dos caracteres con sus frecuencias&quot;);

    class ComparadorNodos {
    public:
        bool operator() (Nodo* nodo1, Nodo* nodo2) const {
            return nodo1-&gt;frecuencia &gt; nodo2-&gt;frecuencia;
        }
    };

    priority_queue&lt;Nodo *, vector&lt;Nodo *&gt;, ComparadorNodos&gt; colaDePrioridad;

    for (const auto caracter : frecuencias) {
        Nodo * nuevo = new Nodo(caracter.first, caracter.second);
        colaDePrioridad.push(nuevo);
        hojas.emplace(caracter.first, nuevo);
    }

    while(colaDePrioridad.size() &gt; 1) {        
        Nodo* n = new Nodo(&#x27; &#x27;, 0);
        n-&gt;izquierdo = colaDePrioridad.top();
        colaDePrioridad.pop();
        n-&gt;derecho = colaDePrioridad.top();
        colaDePrioridad.pop();

        n-&gt;frecuencia = n-&gt;izquierdo-&gt;frecuencia + n-&gt;derecho-&gt;frecuencia;

        n-&gt;izquierdo-&gt;padre = n;
        n-&gt;izquierdo-&gt;bit = &#x27;0&#x27;;

        n-&gt;derecho-&gt;padre = n;
        n-&gt;derecho-&gt;bit = &#x27;1&#x27;;

        colaDePrioridad.push(n);
    }

    raiz = colaDePrioridad.top();
}</code></pre><p id="5bdf0641-fae5-4d70-ba59-a431688a072c" class="block-color-blue">Codificar</p><pre id="0f00ae41-59e4-4d90-847f-dc1f4a257923" class="code"><code>string Huffman::codificar(const string &amp; mensajeACodificar) const {

    string mensajeCodificado, caracterCodificado;
    Nodo * n;
    for (char caracter : mensajeACodificar) {
        try {
            n = hojas.at(caracter);
        } catch (out_of_range error) {
            throw string(&quot;El mensaje a codificar contiene algun caracter que no estaba &quot;)
                + string(&quot;en la tabla de frecuencias inicial (&quot;) + caracter + &quot;).&quot;;
        }

        caracterCodificado = &quot;&quot;;
        while(n != raiz) {
            caracterCodificado += n-&gt;bit;
            n = n-&gt;padre;
        }
        reverse(caracterCodificado.begin(), caracterCodificado.end());
        mensajeCodificado += caracterCodificado;
    }

    return mensajeCodificado;
}</code></pre><p id="44afd5c1-0896-4cdc-8312-387c357095c7" class="block-color-blue">Decodificar</p><pre id="a4671bed-1d75-4384-86d4-ac20379a6062" class="code"><code>string Huffman::decodificar(const string &amp; mensajeADecodificar) const {

    string mensajeDecodificado;
    Nodo * actual = raiz;
    for (char bitMensaje : mensajeADecodificar) {
        if(bitMensaje == &#x27;0&#x27;)
            actual = actual-&gt;izquierdo;
        else
            actual = actual-&gt;izquierdo;

        if (actual-&gt;izquierdo == nullptr) {
            mensajeDecodificado += actual-&gt;caracter;
            actual = raiz;
        }
    }
    return mensajeDecodificado;
}</code></pre></details></li></ul><h3 id="ff3e3419-d7ce-4ef5-93e2-4ca5d0e06076" class="block-color-blue_background"> TEMA 5</h3><ul id="358fadba-5da0-45a2-a3fa-b35fc7d51a95" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Divide y vencerás (Closest Points)</strong></summary><blockquote id="5f598c08-db50-4fa3-a9cf-d5fc49073901" class=""><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA5.2/ClosestPoints_ayuda.html"> Ayuda V</a>. <a href="https://es.wikipedia.org/wiki/Problema_del_par_de_puntos_m%C3%A1s_cercanos#Algoritmo_recursivo_en_el_plano_2D">Ayuda Wikipedia</a></blockquote><pre id="53cc50d3-4371-4d3b-8de2-b2215487df45" class="code"><code>typedef pair&lt;float, float&gt; Punto;

void ver(const vector&lt;Punto&gt; &amp; puntos) {
    for (const auto &amp; p : puntos)
        cout &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot; )&quot;;
}

bool compararY(const Punto &amp; p1, const Punto &amp; p2) {
    return p1.second &lt; p2.second;
}

float distanciaAlCuadrado(const Punto &amp; p1, const Punto &amp; p2) {
    float a = p2.first - p1.first;
    float b = p2.second - p1.second;
    return a * a + b * b;
}

float distanciaAlCuadradoMinima(const vector&lt;Punto&gt; &amp; puntosPorX, const vector&lt;Punto&gt; &amp; puntosPorY) {
    // Caso base de la recursion
    int talla = puntosPorX.size();
    if (talla == 2)
        return distanciaAlCuadrado(puntosPorX[0], puntosPorX[1]);

    if (talla == 3)
        return min({distanciaAlCuadrado(puntosPorX[0], puntosPorX[1]),
                    distanciaAlCuadrado(puntosPorX[0], puntosPorX[2]),
                    distanciaAlCuadrado(puntosPorX[1], puntosPorX[2])});
    
    // Dividimos los vectores en dos mitades
    int tallaIzquierda = talla / 2;

    vector&lt;Punto&gt; mitadIzqX(puntosPorX.begin(), puntosPorX.begin() + tallaIzquierda);
    vector&lt;Punto&gt; mitadDerX(puntosPorX.begin() + tallaIzquierda, puntosPorX.end());
    
    // Dividimos el vector Y en dos mitades. 
    // O(n) gracias a las mitades ordenadas del vector X
    vector&lt;Punto&gt; mitadIzqY(tallaIzquierda);
    vector&lt;Punto&gt; mitadDerY(talla - tallaIzquierda);

    for (int i = 0, j = 0, k = 0; i &lt; talla; i++)
        if (puntosPorY[i] &lt; mitadDerX[0]) // A igual X mira Y, no pueden coincidir X e Y
            mitadIzqY[j++] = puntosPorY[i];
        else
            mitadDerY[k++] = puntosPorY[i];

    // Llamamos a la funcion recursiva pasandole los puntos de la mitad izquierda
    float minimaIzq = distanciaAlCuadradoMinima(mitadIzqX, mitadIzqY);

    // Llamamos a la funcion recursiva pasandole los puntos de la mitad derecha
    float minimaDer = distanciaAlCuadradoMinima(mitadDerX, mitadDerY); 

    // Creamos un vector con los puntos en la franja central ordenados por Y
    float minima = min(minimaIzq, minimaDer);
    vector&lt;Punto&gt; puntosCentralesPorY;
    float frontera = mitadIzqX[tallaIzquierda - 1].first;
    for (auto punto : puntosPorY)
        if (abs(frontera - punto.first) &lt; minima)
            puntosCentralesPorY.push_back(punto);
   
    // Calculamos distancias entre puntos de la franja central con criterio
    // de parada por distancia vertical
    for (int i = 0; i &lt; puntosCentralesPorY.size() - 1; i++)
        for (int j = i + 1;
            j &lt; puntosCentralesPorY.size() &amp;&amp; puntosCentralesPorY[j].second - puntosCentralesPorY[i].second &lt; minima;
            j++)
            minima = min(minima, distanciaAlCuadrado(puntosCentralesPorY[i], puntosCentralesPorY[j]));
        
    return minima;
}

float distanciaMinima(const vector&lt;Punto&gt; &amp; puntos) {
    // Si tenemos menos de dos puntos paramos
    if (puntos.size() &lt; 2)
        throw string (&quot;Necesitamos al menos dos puntos.&quot;);
    
    // Ordenamos los puntos por X en una copia del vector.
    // Si coinciden se mira la Y
    vector&lt;Punto&gt; ordenadosPorX(puntos);
    sort(ordenadosPorX.begin(), ordenadosPorX.end());

    // Detectamos duplicados
    for (int i = 0; i &lt; ordenadosPorX.size() - 1; i++)
        if (ordenadosPorX[i] == ordenadosPorX[i + 1])
            return 0;    

    // Ordenamos los puntos por Y en una copia del vector
    vector&lt;Punto&gt; ordenadosPorY(puntos);
    sort(ordenadosPorY.begin(), ordenadosPorY.end(), compararY);
    
    // Llamamos a la funcion recursiva pasandole los dos vectores de puntos
    return sqrt(distanciaAlCuadradoMinima(ordenadosPorX, ordenadosPorY));
}</code></pre></details></li></ul><ul id="a3442b0d-d068-4207-9c50-aab1c145a752" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Teorema Maestro (Ejercicio 2 y 8 Divide y vencerás V)</strong></summary></details></li></ul><ul id="7666ae97-e6ad-4157-8881-040974c75fb8" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Programación Dinámica </strong><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/estrategias.html#ejercicios53">(Enunciados)</a></summary><ul id="98715258-b1f9-438a-8ab8-e0833bca9614" class="block-color-blue toggle"><li><details open=""><summary>Fibonacci</summary><blockquote id="9824d7ce-2244-4d57-9e59-72d79753dbf2" class="block-color-gray"><em>Ejercicio preliminar para entender el uso de una tabla para guardar resultados y no repetir cálculos</em></blockquote><pre id="46edcf14-6204-4320-8d4f-74dfbda480bd" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE 
***************************************************************************/
long long fibonacci(int n) {
    long long resultado
    if (n &lt;= 1)
        resultado = n;
    else
        resultado = fibonacci(n - 1) + fibonacci(n - 2);
    return resultado;
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
long long fibonacci(int n, vector&lt;long long&gt; &amp; resultado) {
    if (resultado[n] == DESCONOCIDO) {
        if (n &lt;= 1)
            resultado[n] = n;
        else 
            resultado[n] = fibonacci(n - 1, resultado) 
                           + fibonacci(n - 2, resultado);
    }
    return resultado[n];
}

long long fibonacci(int n) {
    vector&lt;long long&gt; resultado(n + 1, DESCONOCIDO);
    return fibonacci(n, resultado);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
long long fibonacci(int n) {
    
    long long resultado;

    if (n &lt;= 1)
        resultado = n;
    else {
        long long penultimo = 0, ultimo = 1;
        for (int i = 2; i &lt;= n; i++) {
            resultado = ultimo + penultimo;
            penultimo = ultimo;
            ultmo = resultado;
        }
    }

    return resultado;
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
**************************************************************************/
int main() {
    
    for (int dato = 10; dato &lt;= 50; dato += 5) {
        cout &lt;&lt; &quot;Fibonacci (&quot; &lt;&lt; dato &lt;&lt; &quot;) = &quot;;
        cout &lt;&lt; &quot;\t&quot; &lt;&lt; fibonacci(dato) &lt;&lt; endl;
    }
}</code></pre></details></li></ul><ul id="fa44793a-486f-444d-81ec-4e3a9b0ee5bf" class="block-color-blue toggle"><li><details open=""><summary>Maximo de Puntos en el Escenario</summary><blockquote id="dd4ab0c7-9ff1-485c-a12a-166d989e8611" class="block-color-gray"><em>En este ejercicio, donde se busca conseguir el máximo de puntos desde un origen hasta un destino yendo únicamente hacia la derecha y hacia abajo, se introduce el uso de la función max y min, donde recursivamente se suma al resultado la opción que nos interese más, en este caso el mayor por la derecha o el mayor por abajo. También se cubren las demás posibilidades en las que habrá una pared o iremos únicamente en una dirección, que basta con ir sumando resultados recursivamente. El ejercicio también se puede resolver al revés, partiendo de la casilla objetivo y yendo hacia arriba y hacia la izquierda.</em></blockquote><pre id="863e0c5b-04ae-4081-9928-04bef346fdcb" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
#define PARED -1
#define DESCONOCIDO -1

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos, 
                int x, 
                int y) {
    int ultimaFila = puntos.size() - 1, ultimaColumna = puntos[0].size() - 1;
    float resultado;

    if (puntos[x][y] == PARED)
        resultado = -INFINITO;
    else if (x ==  ultimaFila &amp;&amp; y == ultimaColumna)
        resultado = puntos[x][y];
    else if (x == ultimaFila)
        resultado = puntos[x][y] + maxPuntos(puntos, resultado, x, y + 1);
    else if (y == ultimaColumna)
        resultado = puntos[x][y] + maxPuntos(puntos, resultado, x + 1, y);
    else
        resultado =  puntos[x][y] + max(maxPuntos(puntos, resultado, x + 1, y),
                                        maxPuntos(puntos, resultado, x, y + 1));

    return resultado;
}

float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos) {
    return maxPuntos(puntos, resultado, 0, 0);
} 

/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos, 
                vector&lt;vector&lt;float&gt;&gt; &amp; resultado, 
                int x, 
                int y) {
                    
    int ultimaFila = puntos.size() - 1;
    int ultimaColumna = puntos[0].size() - 1;
    

    if (resultado[x][y] == DESCONOCIDO) {
        if (puntos[x][y] == PARED)
            resultado[x][y] = -INFINITO;
        else if (x == ultimaFila &amp;&amp; y == ultimaColumna)
            resultado[x][y] = puntos[x][y];
        else if (x == ultimaFila)
            resultado[x][y] = puntos[x][y] + maxPuntos(puntos, resultado, x, y + 1);
        else if (y == ultimaColumna)
            resultado[x][y] = puntos[x][y] + maxPuntos(puntos, resultado, x + 1, y);
        else
            resultado[x][y] =  puntos[x][y] + max(maxPuntos(puntos, resultado, x + 1, y),
                                                  maxPuntos(puntos, resultado, x, y + 1));
    }

    return resultado[x][y];
}

float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos) {
    int cantidadFilas = puntos.size(), cantidadColumnas = puntos[0].size();
    vector&lt;float&gt; valorVectorResultado(cantidadColumnas, DESCONOCIDO);

    vector&lt;vector&lt;float&gt;&gt; resultado(cantidadFilas, valorVectorResultado);
    return maxPuntos(puntos, resultado, 0, 0);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos) {

    int ultimaFila = puntos.size() - 1, ultimaColumna = puntos[0].size() - 1;
    vector&lt;vector&lt;float&gt;&gt; resultado(ultimaFila + 1, vector&lt;float&gt;(ultimaColumna + 1));

    for (int fila = ultimaFila; fila &gt;= 0; fila--)

        for (int columna = ultimaColumna; columna &gt;= 0; columna--) 

            if (puntos[fila][columna] == -1)
                resultado[fila][columna] = -INFINITO;

            else if (fila == ultimaFila &amp;&amp; columna == ultimaColumna)
                resultado[fila][columna] = puntos[fila][columna];

            else if (fila == ultimaFila)
                resultado[fila][columna] = puntos[fila][columna] + resultado[fila][columna + 1];

            else if (fila == ultimaFila)
                resultado[fila][columna] = puntos[fila][columna] + resultado[fila][columna];

            else
                resultado[fila][columna] = puntos[fila][columna] + max(resultado[fila][columna + 1],
                                                                       resultado[fila + 1][columna]);
    
    return resultado[0][0];
}


/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main()  {
    vector&lt;vector&lt;float&gt;&gt; ejemplo = {{3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                                     {0,  5,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1,  0,  0},
                                     {0,  0,  0, -1, -1,  1,  3, -1, -1,  0,  0,  0, -1,  0,  0},
                                     {0,  5,  0,  9, -1,  2,  4, -1,  9,  0,  0,  0, -1,  0,  0},
                                     {-1, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1,  0,  5},
                                     {-1, 0,  0,  3,  2, -1, -1,  2,  3,  0,  0,  0, -1,  0,  0},
                                     {-1, 0,  0,  4, -1, -1, -1, -1,  4,  0,  0,  0, -1,  0,  5},
                                     {0,  0,  0, -1, -1, -1, -1, -1, -1,  0,  0,  0, -1,  0,  0},
                                     {7,  0,  0,  1,  1,  1,  1,  1,  1,  0,  0,  0, -1,  0,  5},
                                     {0,  0,  0,  0, -1, -1, -1, -1,  1,  1,  1,  1,  1,  2,  4}};


    float cantidadMaxima = maxPuntos(ejemplo);
    cout &lt;&lt; &quot;Cantidad de puntos maxima: &quot; &lt;&lt; cantidadMaxima &lt;&lt; endl;
    if (cantidadMaxima == 41)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else 
       cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="a404ba36-c197-474a-9518-ad90e35dc462" class="block-color-blue toggle"><li><details open=""><summary>Competición de Videojuegos</summary><blockquote id="9e2413c9-b457-4dbe-8585-7575e2a9bbb1" class="block-color-gray"><em>Ejercicio de entrenamiento muy similar al anterior. En este caso tendremos que tener cuidado, como siempre, en la condición en la que debemos elegir entre dos opciones. El truco está en si posponer el inscribirnos en un premio o elegir el actual, siendo el siguiente disponible el que nos marca la clase ´partida´ como primer posterior.</em></blockquote><pre id="a0a6daa1-4389-4046-8c26-cd8a9bcf0679" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct Partida {
    int inicio;
    int final;
    float premio;
    int primeraPosterior;
};  


/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float maximoPremio(const vector&lt;Partida&gt; &amp; competicion,
                    int partida) {
    float resultado;

    if (partida == competicion.size() - 1)
        resultado = competicion[partida].premio;
    else if (competicion[partida].primeraPosterior == -1)
        resultado = max(competicion[partida].premio, 
                        maximoPremio(competicion, partida + 1));
    else
        resultado = max(competicion[partida].premio + maximoPremio(competicion, competicion[partida].primeraPosterior),
                         maximoPremio(competicion, partida + 1));

    return resultado;
}

float maximoPremio(const vector&lt;Partida&gt; &amp; competicion) {

    return maximoPremio(competicion, 0);
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float maximoPremio(vector&lt;float&gt; &amp; resultado, 
                   const vector&lt;Partida&gt; &amp; competicion,
                   int partida) {

    if (resultado[partida] == DESCONOCIDO) {
        if (partida == competicion.size() - 1)
            resultado[partida] = competicion[partida].premio;
        else if (competicion[partida].primeraPosterior == -1)
            resultado[partida] = max(competicion[partida].premio, 
                            maximoPremio(resultado, competicion, partida + 1));
        else
            resultado[partida] = max(competicion[partida].premio + maximoPremio(resultado, competicion, competicion[partida].primeraPosterior),
                            maximoPremio(resultado, competicion, partida + 1));
    }

    return resultado[partida];
}

float maximoPremio(const vector&lt;Partida&gt; &amp; competicion) {

    vector&lt;float&gt; resultado(competicion.size(), DESCONOCIDO);

    return maximoPremio(resultado, competicion, 0);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float maximoPremio(const vector&lt;Partida&gt; &amp; competicion) {

    vector&lt;float&gt; resultado(competicion.size());

    for (int partida = competicion.size() - 1; partida &gt;= 0; partida--)
        if (partida == competicion.size() - 1)
            resultado[partida] = competicion[partida].premio;
        else if (competicion[partida].primeraPosterior == -1)
            resultado[partida] = max(competicion[partida].premio,
                                     resultado[partida + 1]);
        else
            resultado[partida] = max(competicion[partida].premio + resultado[competicion[partida].primeraPosterior],
                                     resultado[partida + 1]);

    return resultado[0];
}

/***************************************************************************
* TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;Partida&gt; ejemploCompeticion = {  {10, 14, 7000, 3},
                                            {11, 12, 3000, 2},
                                            {13, 17, 9000, 5},
                                            {15, 17, 5000, 5},
                                            {16, 19, 8000, -1},
                                            {17, 18, 2000, -1}  };


    float resultado = maximoPremio(ejemploCompeticion);
    cout &lt;&lt; &quot;Maximo premio: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 15000)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="aaf56ba1-2af2-4f8d-a0ff-bb64293fab0c" class="block-color-blue toggle"><li><details open=""><summary>Valores de Casas</summary><blockquote id="79694c7b-96c4-4e77-b154-8f8038e5120c" class="block-color-gray"><em>Muy similar al anterior. En este caso se decide entre si posponer el empezar a robar casas o empezar ya pero avanzando, como mínimo, a la segunda que nos encontremos desde donde estamos, ya que los vecinos se avisarían entre ellos y nos detendrían. Si esta condición la repetimos podemos ver que el posponer robar cubre también la decisión de cuantas casas esperarnos una vez hayamos comenzado a robar.</em></blockquote><pre id="a33b72a0-c074-4e3f-a088-d3bfd9586229" class="code"><code>// COMPLETA LO QUE FALTA

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas,
                         int casa) {
    
    float resultado;
    if (casa &gt;= valoresCasas.size() - 1)
        resultado = valoresCasas[casa];
    else if (casa == valoresCasas.size() - 2)
        resultado = max(valoresCasas[casa], valoresCasas[casa + 1]);

    else
        resultado = max(valoresCasas[casa] + maximoValorRobable(valoresCasas, casa + 2),
                        maximoValorRobable(valoresCasas, casa + 1));

    return resultado;
}


float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas) {

    int primeraCasa = 0;
    return maximoValorRobable(valoresCasas, primeraCasa);
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float maximoValorRobable(vector&lt;float&gt; &amp; resultado,
                         const vector&lt;float&gt; &amp; valoresCasas,
                         int casa) {
    
    if (resultado[casa] == DESCONOCIDO)
        if (casa &gt;= valoresCasas.size() - 1)
            resultado[casa] = valoresCasas[casa];
        else if (casa == valoresCasas.size() - 2)
            resultado[casa] = max(valoresCasas[casa], valoresCasas[casa + 1]);

        else
            resultado[casa] = max(valoresCasas[casa] + maximoValorRobable(resultado, valoresCasas, casa + 2),
                            maximoValorRobable(resultado, valoresCasas, casa + 1));
                            
    return resultado[casa];
}


float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas) {

    vector&lt;float&gt; resultado(valoresCasas.size(), DESCONOCIDO);
    int primeraCasa = 0;
    return maximoValorRobable(resultado, valoresCasas, primeraCasa);
}

/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas) {
    
    vector&lt;float&gt; resultado(valoresCasas.size());
    int casa;

    for (casa = valoresCasas.size() - 1; casa &gt;= 0; casa--)
        if (casa &gt;= valoresCasas.size() - 1)
            resultado[casa] = valoresCasas[casa];
        else if (casa == valoresCasas.size() - 2)
            resultado[casa] = max(valoresCasas[casa], valoresCasas[casa + 1]);

        else
            resultado[casa] = max(valoresCasas[casa] + resultado[casa + 2],
                                  resultado[casa + 1]);
                            
    return resultado[0];
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    
    vector&lt;float&gt; calleMayor = {6000, 10000, 3000, 15000, 4000, 2000, 8000, 5000};
    vector&lt;float&gt; calleAlta = {3000, 6000, 7000, 5000};

    float resultado = maximoValorRobable(calleAlta);
    cout &lt;&lt; &quot;Maximo valor robable en calle Alta: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 11000)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else   
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
    
    resultado = maximoValorRobable(calleMayor);
    cout &lt;&lt; &quot;Maximo valor robable en calle Mayor: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 33000)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else   
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="fba81691-aa86-423f-b76e-18c45716ab13" class="block-color-blue toggle"><li><details open=""><summary>Coste Colorear Casas</summary><blockquote id="4ce585ba-4185-4ab2-af57-82fbf795410a" class="block-color-gray">Lo más importante que se ve en este ejercicio es la forma en la que elige el mínimo entre varios caminos posibles, con una variable que guardará el mínimo y un for que iterará entre todas las opciones, quedándonos con la que tenemos guardada en mínimo o la que estamos mirando<em>. También es interesante cómo desde la llama inicial de la recursividad se aprovecha para averiguar cuál sería la casa por la que mas nos merecería la pena empezar, eligiendo el mínimo entre varias posibilidades como veremos más tarde en el ejercicio de las aldeas (</em>#include &lt;algorithm&gt; // min({ ... })<em>.</em></blockquote><pre id="c7bc1294-0339-4f63-87c5-cafd5032dc24" class="code"><code>// COMPLETA LO QUE FALTA
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // min({ ... })

#include &lt;limits&gt;
#define INFINITO numeric_limits&lt;float&gt;::infinity()

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura,
                         int color,
                         int casa) {
    
    float resultado;

    if (casa == costePintura[0].size() - 1)
        resultado = costePintura[color][casa];
    else {
        float minimo = INFINITO;
        for (int otroColor = 0; otroColor &lt; costePintura.size(); otroColor++)
            if (otroColor != color)
                minimo = min(minimo,
                             costePintura[color][casa] + minimoCostePintura(costePintura, 
                                                                            otroColor, 
                                                                            casa + 1));
        resultado = minimo;
    }
    return resultado;
}

float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura) {

    int casa = 0;
    return min({minimoCostePintura(costePintura, 0, casa),
                minimoCostePintura(costePintura, 1, casa),
                minimoCostePintura(costePintura, 2, casa) });
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePintura(vector&lt;vector&lt;float&gt;&gt; &amp; resultado,
                         const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura,
                         int color,
                         int casa) {

    if (resultado[color][casa] == DESCONOCIDO) {
        if (casa == costePintura[0].size() - 1)
            resultado[color][casa] = costePintura[color][casa];
        else {
            float minimo = INFINITO;
            for (int otroColor = 0; otroColor &lt; costePintura.size(); otroColor++)
                if (otroColor != color)
                    minimo = min(minimo,
                                costePintura[color][casa] + minimoCostePintura(resultado,
                                                                               costePintura, 
                                                                               otroColor, 
                                                                               casa + 1));
            resultado[color][casa] = minimo;
        }
    }
    return resultado[color][casa];
}

float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura) {
    vector&lt;vector&lt;float&gt;&gt; resultado(costePintura.size(), 
                                    vector&lt;float&gt;(costePintura[0].size(), DESCONOCIDO));
    int casa = 0;
    return min({minimoCostePintura(resultado, costePintura, 0, casa),
                minimoCostePintura(resultado, costePintura, 1, casa),
                minimoCostePintura(resultado, costePintura, 2, casa) });
}

/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura) {

    int numeroCasas = costePintura[0].size();
    vector&lt;vector&lt;float&gt;&gt; resultado(3, vector&lt;float&gt;(numeroCasas));

    for (int casa = 0; casa &lt; numeroCasas; casa++)
        for (int color = 0; color &lt; 3; color++)
            if (casa == 0)
                resultado[color][casa] = costePintura[color][casa];
            else {
                float minimo = INFINITO;
                for (int otroColor = 0; otroColor &lt; 3; otroColor++)
                    if (otroColor != color)
                        minimo = min(minimo,
                                     costePintura[color][casa] + resultado[otroColor][casa - 1]);
                resultado[color][casa] = minimo;
            }
    
    return min({resultado[0][numeroCasas - 1],
                resultado[1][numeroCasas - 1],
                resultado[2][numeroCasas - 1]});
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    
    vector&lt;vector&lt;float&gt;&gt; ejemploCostePintura = { {300,  600,  200, 1000, 1500, 500, 900},
                                                  {400,  1600, 400, 700,  1200, 400, 200},
                                                  {500,  1300, 600, 100,  300,  500, 800} };

    float resultado = minimoCostePintura(ejemploCostePintura);
    cout &lt;&lt; &quot;Minimo coste pintura: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 3300)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else   
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="0e343242-ef49-43a5-99af-4a5453dbee8b" class="block-color-blue toggle"><li><details open=""><summary>Río Aldeas</summary><blockquote id="267c5da3-bb25-42dc-866f-376494142251" class="block-color-gray"><em>En este ejercicio hay que vigilar los casos de fin de la recursión y tener cuidado con lo que debemos devolver. Se puede resolver el ejercicio empezando desde la aldea origen o desde la aldea destino.</em></blockquote><pre id="9314c4fa-8fc5-4788-9136-99218d0909c0" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo,
                        int aldea) {

    float resultado;

    int ultimaAldea = paseoCorto.size();
    
    if (aldea == ultimaAldea)
        resultado = 0;    
    else if(aldea == ultimaAldea - 1)
        resultado = paseoCorto[aldea];
    else
        resultado = min(paseoCorto[aldea] + minimoCostePaseo(paseoCorto, paseoLargo, aldea + 1),
                        paseoLargo[aldea] + minimoCostePaseo(paseoCorto, paseoLargo, aldea + 2));

    return resultado;
}

float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo) {
    int primeraAldea = 0;
    return minimoCostePaseo(paseoCorto, paseoLargo, primeraAldea);
}


#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePaseo (vector&lt;float&gt; &amp; resultado,
                        const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo,
                        int aldea) {

    if(resultado[aldea] == DESCONOCIDO) {

        int ultimaAldea = paseoCorto.size();

        if (aldea == ultimaAldea)
            resultado[aldea] = 0;    
        else if(aldea == ultimaAldea - 1)
            resultado[aldea] = paseoCorto[aldea];
        else
            resultado[aldea] = min(paseoCorto[aldea] + minimoCostePaseo(resultado, paseoCorto, paseoLargo, aldea + 1),
                            paseoLargo[aldea] + minimoCostePaseo(resultado, paseoCorto, paseoLargo, aldea + 2));
    }

    return resultado[aldea];
}

float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo) {
    int primeraAldea = 0;
    vector&lt;float&gt; resultado(paseoCorto.size(), DESCONOCIDO);
    return minimoCostePaseo(resultado, paseoCorto, paseoLargo, primeraAldea);
}

/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo) {

    vector&lt;float&gt; resultado(paseoCorto.size() + 1);

    int ultimaAldea = paseoCorto.size();

    for (int aldea = paseoCorto.size(); aldea &gt;= 0; aldea--) 
        if (aldea == ultimaAldea)
            resultado[aldea] = 0;    
        else if(aldea == ultimaAldea - 1)
            resultado[aldea] = paseoCorto[aldea];
        else
            resultado[aldea] = min(resultado[aldea + 1] + paseoCorto[aldea],
                                   resultado[aldea + 2] + paseoLargo[aldea]);

    return resultado[0];
}


/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;float&gt; ejemploPaseoCorto = {80, 20,  60,  50, 90, 10};
    vector&lt;float&gt; ejemploPaseoLargo = {70, 30, 100, 110, 40};

    float resultado = minimoCostePaseo(ejemploPaseoCorto, ejemploPaseoLargo);
    cout &lt;&lt; &quot;Minimo coste paseo: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 200)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="7870ea2d-7122-4106-8945-547626298905" class="block-color-blue toggle"><li><details open=""><summary>Río Aldeas II</summary><blockquote id="1d0fae66-03d2-41cb-9023-d2bff11bc87d" class="block-color-gray"><em>Es un ejercicio parecido a todos los anteriores. De nuevo podemos solucionar el ejercicio partiendo desde el origen o desde el destino. En este caso se usa una variable intento para no tener que usar la función min, pero funciona de la misma forma.</em></blockquote><pre id="3e551206-75d7-4d30-97db-075d2a16aa02" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

#include &lt;limits&gt;
#define INFINITO numeric_limits&lt;float&gt;::infinity()

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler,
                  int aldea) {

    float resultado;

    int ultimaAldea = costeAlquiler.size() - 1;
    if (aldea == ultimaAldea)
        resultado = 0;
    else {
        float minimo = INFINITO;
        for (int siguienteAldea = aldea + 1; siguienteAldea &lt; costeAlquiler.size(); siguienteAldea++) {
            float intento = costeAlquiler[aldea][siguienteAldea] + minimoCoste(costeAlquiler, siguienteAldea));
            if (intento &lt; minimo)
                minimo = intento;
        }
        resultado = minimo;
    }

    return resultado;
}

float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler) {
    
    int primerasiguienteAldea = 0;
    return minimoCoste(costeAlquiler, primerasiguienteAldea);
}


#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCoste(vector&lt;float&gt; &amp; resultado,
                  const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler,
                  int aldea) {

    
    if (resultado[aldea] == DESCONOCIDO) {
        int ultimaAldea = costeAlquiler.size() - 1;
        if (aldea == ultimaAldea)
            resultado[aldea] = 0;
        else {
            float minimo = INFINITO;
            for (int siguienteAldea = aldea + 1; siguienteAldea &lt; costeAlquiler.size(); siguienteAldea++) {
                float intento = costeAlquiler[aldea][siguienteAldea] + minimoCoste(resultado, costeAlquiler, siguienteAldea));
                if (intento &lt; minimo)
                    minimo = intento;
            }
            resultado[aldea]  = minimo;
        }
    }

    return resultado[aldea];
}

float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler) {

    vector&lt;float&gt; resultado(costeAlquiler.size(), DESCONOCIDO);
    int primerasiguienteAldea = 0;
    return minimoCoste(resultado, costeAlquiler, primerasiguienteAldea);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler) {

    vector&lt;float&gt; resultado(costeAlquiler.size(), DESCONOCIDO);
    
    int ultimaAldea = costeAlquiler.size() - 1;
    for (int aldea = ultimaAldea; aldea &gt;= 0; aldea--) {
        if (aldea == ultimaAldea)
            resultado[aldea] = 0;
        else {
            float minimo = INFINITO;
            for (int siguienteAldea = aldea + 1; siguienteAldea &lt;= ultimaAldea; siguienteAldea++) {
                float intento = resultado[siguienteAldea] + costeAlquiler[aldea][siguienteAldea];
                if (intento &lt; minimo)
                    minimo = intento;
            }
            resultado[aldea]  = minimo;
        }
    }
    
    return resultado[0];
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;vector&lt;float&gt;&gt; ejemplo = {{0, 70, 30, 20, 90},
                                     {0,  0,  0, 60, 10},
                                     {0,  0,  0, 50, 40},
                                     {0,  0,  0,  0, 80},
                                     {0,  0,  0,  0,  0}};
    
    float resultado = minimoCoste(ejemplo);
    cout &lt;&lt; &quot;Coste minimo: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 70)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else       
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="c87018a0-f922-48cd-8639-bf4b55d1cb3c" class="block-color-blue toggle"><li><details open=""><summary>Cambio de Monedas</summary><blockquote id="6fd24725-2c7d-4a40-b855-e730fbfb92d0" class="block-color-gray"><em>La dificultad de este ejercicio es idear la manera en que controla la deuda restante y cómo va mirando todas las opciones según que moneda usar para restar, ya que solo va a tener éxito si la deuda llega a cero, ni más ni menos, quedándose con el número de monedas mínimo.</em></blockquote><pre id="3ca02423-8e07-4254-b507-a53198fcb4a0" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // min({ ... })

using namespace std;

#include &lt;limits&gt;
#define INFINITO numeric_limits&lt;float&gt;::infinity()

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
int minimaCantidadMonedas(const vector&lt;int&gt; &amp; valoresMonedas,
                            int deudaRestante) {
    int resultado;

    if (deudaRestante == 0)
        resultado = 0;
    else {
        int minimo = deudaRestante;
        for (int valor : valoresMonedas)
           if (deudaRestante - valor &gt;= 0)
               minimo = min(minimo,
                            1 + minimaCantidadMonedas(valoresMonedas, deudaRestante - valor));
        resultado = minimo;
    }

    return resultado;    
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
int minimaCantidadMonedas(vector&lt;int&gt; &amp; resultado,
                            const vector&lt;int&gt; &amp; valoresMonedas,
                            int deudaRestante) {
    if (resultado[deudaRestante] == DESCONOCIDO)
        if (deudaRestante == 0)
            resultado[deudaRestante] = 0;
        else {
            int minimo = deudaRestante;
            for (int valor : valoresMonedas)
                if (deudaRestante - valor &gt;= 0)
                    minimo = min(minimo,
                                 1 + minimaCantidadMonedas(resultado, valoresMonedas, deudaRestante - valor));
            resultado[deudaRestante] = minimo;
        }

    return resultado[deudaRestante];    
}

int minimaCantidadMonedas(const vector&lt;int&gt; &amp; valoresMonedas, 
                          int deuda) {
                              
    vector&lt;int&gt; resultado(deuda + 1, DESCONOCIDO);
    return minimaCantidadMonedas(resultado, valoresMonedas, deuda);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
void mostrarMonedasElegidas(const vector&lt;int&gt; &amp; valoresMonedas,
                            vector&lt;int&gt; &amp; resultado) {

    int deuda = resultado.size() - 1;                                

    while(deuda &gt; 0) 
        for (int valor : valoresMonedas)
            if (deuda - valor &gt;= 0
                &amp;&amp; resultado[deuda] == resultado[deuda - valor] + 1) {
                cout &lt;&lt; &quot;dale &quot; &lt;&lt; valor &lt;&lt; endl;
                deuda -= valor;
                break;
                }
}
int minimaCantidadMonedas(const vector&lt;int&gt; &amp; valoresMonedas, 
                          int deuda) {

    vector&lt;int&gt; resultado(deuda + 1);
    for (int deudaRestante = 0; deudaRestante &lt;= deuda; deudaRestante++) {    
        if (deudaRestante == 0)
            resultado[deudaRestante] = 0;
        else {
            int minimo = deudaRestante;
            for (int valor : valoresMonedas)
                if (deudaRestante - valor &gt;= 0)
                    minimo = min(minimo, 1 + resultado[deudaRestante - valor]);
            resultado[deudaRestante] = minimo;
        }
    }
    mostrarMonedasElegidas(valoresMonedas, resultado);
    return resultado[deuda];    
}


/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;int&gt; monedasMordor =  {5, 21, 1, 25};
    vector&lt;int&gt; monedasPandora = {1,  4, 6, 10};

    int resultado;

    cout &lt;&lt; &quot;Probando monedas de Mordor:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 22&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasMordor, 22);
    cout &lt;&lt;  &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 2)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 63&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasMordor, 63);
    cout &lt;&lt;  &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 3)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Deuda: 65&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasMordor, 65);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 5)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Probando monedas de Mordor:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 22&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasPandora, 22);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 3)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Deuda: 63&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasPandora, 63);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 8)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 65&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasPandora, 65);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 8)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
}</code></pre></details></li></ul></details></li></ul><h3 id="27141511-29d2-4c50-8123-e44abd6fcd2b" class="block-color-blue_background"> TEMA 6</h3><ul id="f67c2886-c8ad-4b75-9535-9d654fec48c0" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Búsqueda en anchura</strong></summary><blockquote id="3a0aabc6-fd90-44aa-b2bf-e5c2fade6471" class="block-color-gray"><em>La estructura es similar a la que se vio en el tema de árboles. En este tema recurriremos frecuentemente a un vector de booleanos para comprobar si hemos visitado ya o no el nodo que vamos a mirar. En este caso se usa únicamente el vector de enteros que marca el camino hacia el origen, ya que, si el nodo está marcado con un número diferente al -1 consideramos que aún no ha sido visitado.                                                                   Para estos ejercicios se hace uso de una clase ColaDePrioridadDecrementable que nos permite cambiar la prioridad de un elemento, eliminar el mínimo, que en esta implementación también nos lo devuelve y un último método para insertar.</em></blockquote><p id="91942ab4-1de1-47e7-a6fa-966b24e88d0b" class="block-color-blue">Caminos Óptimos sin pesos</p><pre id="160df890-a092-49e8-bed2-550970d622f9" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;int&gt; GrafoNoDirigido::arbolDeCaminosOptimosConPesos(int origen) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; padre(vertices.size(), -1);

    padre[origen] = -2;
    pesoCaminoOptimo[origen] = 0;
    
    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            float nuevoPeso = pesoCaminoOptimo[v] + arco-&gt;peso;
            if (nuevoPeso &lt; pesoCaminoOptimo[arco-&gt;vecino]) {
                pesoCaminoOptimo[arco-&gt;vecino] = nuevoPeso;
                padre[arco-&gt;vecino] = v;
                pq.cambiarPrioridad(arco-&gt;vecino, nuevoPeso);
            }
        }
    }

    return padre;
}</code></pre><p id="c5ab2837-b24e-4f6e-94d8-04c6d30d098e" class="">
</p><p id="c494b8b3-2973-4bf7-89b6-d8b959de88eb" class="block-color-blue">Alcanzabilidad</p><pre id="56b82028-0ba3-4278-a44b-e79a2db43ca2" class="code"><code>bool GrafoDirigido::todosAlcanzablesDesdeVertice(int s) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    queue&lt;int&gt; cola;

    visitado[s] = true;
    cola.push(s);
    int contadorVisitados = 1;

    while (!cola.empty()) {
        int v = cola.front();
        cola.pop();

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
            if (visitado[arco-&gt;vecino] == false) {
                visitado[arco-&gt;vecino] = true;
                cola.push(arco-&gt;vecino);
                contadorVisitados++;
            }
    }
    
    return contadorVisitados == vertices.size();
}</code></pre><p id="778f2f56-3ff0-42b1-9339-0fc95b38df43" class="">
</p><blockquote id="c3c6250d-67e7-401c-a4be-6a6b682e46ce" class="block-color-gray"><em>Para ver la conectividad se comprueba únicamente que un origen puede llegar a todos y que, haciendo uso de sus arcos de entrada puede de igual manera visitar todos los nodos. De esta forma solo tendrá que recorrer el grafo dos veces.</em></blockquote><p id="1e87d579-20d9-4353-a803-eaccee9105a8" class="block-color-blue">Conectividad</p><pre id="eb382f20-b118-4a27-a787-9141834cb49c" class="code"><code>bool GrafoDirigido::verticeAlcanzableDesdeTodos(int s) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    queue&lt;int&gt; cola;

    visitado[s] = true;
    cola.push(s);
    int contadorVisitados = 1;

    while (!cola.empty()) {
        int v = cola.front();
        cola.pop();

        for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
            if (visitado[arco-&gt;vecino] == false) {
                visitado[arco-&gt;vecino] = true;
                cola.push(arco-&gt;vecino);
                contadorVisitados++;
            }
    }
    return contadorVisitados == vertices.size();
}


bool GrafoDirigido::esFuertementeConexo() const {
 
    int origen = 0;
    return todosAlcanzablesDesdeVertice(origen) &amp;&amp; verticeAlcanzableDesdeTodos(origen);
}</code></pre><p id="66d5260b-ce59-4c7e-bbd5-bce2155f9668" class="">
</p><p id="37f60f14-132c-47fc-949d-023a07d7c3df" class="block-color-blue">Ordenación Topológica mediante <a href="https://www.cs.usfca.edu/~galles/visualization/TopoSortIndegree.html">Kahn</a></p><pre id="c9bd5b2a-782e-4ead-8b9a-9b539fe0fa88" class="code"><code>void GrafoDirigido::mostrarOrdenTopologico() const {

    cout &lt;&lt; &quot;Ordenacion topologica: &quot; &lt;&lt; endl;

    vector&lt;int&gt; entradasRestantes(vertices.size());
    vector&lt;int&gt; ordenTopologico(vertices.size());
    queue&lt;int&gt; ceroGrados;
    int contadorDeVertices = 0;

    for (int v = 0; v &lt; vertices.size(); v++) {
        entradasRestantes[v] = vertices[v].gradoDeEntrada;
        if (entradasRestantes[v] == 0)
            ceroGrados.push(v);
    }

    while (!ceroGrados.empty()) {
        int v = ceroGrados.front();
        ceroGrados.pop();
        ordenTopologico[contadorDeVertices++] = v;

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente) {
            if (--entradasRestantes[arco-&gt;vecino] == 0)
                ceroGrados.push(arco-&gt;vecino);
        }
    }
    
    if (contadorDeVertices != vertices.size())
        throw string(&quot;ERROR: el grafo no es aciclico&quot;);

    for (int v : ordenTopologico)
        cout &lt;&lt; v &lt;&lt; endl;
}</code></pre><p id="efddb728-7d64-4cfb-9ea3-c32899b85cdf" class="">
</p><blockquote id="c76a29d5-2065-4c1f-99a9-78d79092ebdd" class="block-color-gray"><em>El algoritmo de Kahn permite resolver si el grafo tiene ciclos o no, mediante el uso de un contador de vertices que comprobara que hemos visitado todos los vertices que tenemos en el grafo, ni más ni menos.</em></blockquote><p id="4e54bc15-8b56-4704-b4cf-c514bf5b5eef" class="block-color-blue">Aciclicidad mediante Kahn</p><pre id="d274aa62-ce9d-4fec-857f-6849c887819b" class="code"><code>bool GrafoDirigido::esAciclico() const {

    vector&lt;int&gt; entradasRestantes(vertices.size());
    queue&lt;int&gt; caja;
    int contadorDeVertices = 0;

    for (int v = 0; v &lt; vertices.size(); v++) {
        entradasRestantes[v] = vertices[v].gradoDeEntrada;
        if (entradasRestantes[v] == 0)
            caja.push(v);
    }

    while (!caja.empty()) {
        int v = caja.front();
        caja.pop();

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
            if (--entradasRestantes[arco-&gt;vecino] == 0)
                caja.push(arco-&gt;vecino);
    }
    
    return contadorDeVertices != vertices.size();
}</code></pre><p id="b2ba7892-0692-4f3c-ac03-9fad6aadcc75" class="">
</p><blockquote id="30860940-0412-4970-aa74-666bc9d7e690" class="block-color-gray"><em>La búsqueda en anchura nos permite recorrer el grafo de manera similar a como recorríamos los árboles por niveles. En este caso se hace uso de una variable distancia para saber cuando avanzamos de nivel en el grafo, es decir, cuando la distancia de arcos desde el vértice original aumenta. También podríamos hacer uso de un vector de enteros que guardase la información de la distancia de cada vértice y parar cuando se llegue al deseado.</em></blockquote><p id="44526e0c-fbf7-4b22-904a-0fe40719e953" class="block-color-blue">Contar caminos cercanos (Mínimos arcos necesarios)</p><pre id="ba2163f0-6ea4-46d4-b9b6-c8304d0b1805" class="code"><code>int GrafoNoDirigido::contarEnemigosCercanos(int islaJugador,
                                            int puentes,
                                            const vector&lt;int&gt; &amp; cantidadEnemigos) const {
    
    vector&lt;bool&gt; visitado(vertices.size(), false);
    vector&lt;int&gt; distancia(vertices.size());
    queue&lt;int&gt; cola;

    distancia[islaJugador] = 0;
    visitado[islaJugador] = true;    
    cola.push(islaJugador);
    int resultado = cantidadEnemigos[islaJugador];


    while (!cola.empty()) {
        int v = cola.front();
        cola.pop();

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente)
            if (!visitado[arco-&gt;vecino]) {
                distancia[arco-&gt;vecino] = distancia[v] + 1;
                visitado[arco-&gt;vecino] = true;
                resultado += cantidadEnemigos[arco-&gt;vecino];
                if (distancia[arco-&gt;vecino] &lt; puentes)
                    cola.push(arco-&gt;vecino);
            }
    }

    return resultado;
}</code></pre><p id="dc0af2fe-013a-46c8-baec-b3a00335ec38" class="">
</p><blockquote id="cde65609-4360-45cf-a422-bca8c6bd0195" class="block-color-gray"><em>Solución basada en el algoritmo de Khan, se hace uso de un contador que mantiene actualizada la talla de cada nivel, siempre cuando esta se acaba se actualiza su valor con los vértices que haya almacenados en la cola en ese momento, que no será otro que los que se encuentran en un nivel superior al actual, tal y como lo hacíamos con los árboles</em></blockquote><p id="a4a5c9b3-533d-4922-b081-97c2bdd5a702" class="block-color-blue">Minima cantidad de Años</p><pre id="b19ad33d-4f05-4f16-8bec-688e0404d063" class="code"><code>int GrafoDirigido::minimaCantidadAnyos() const {

    vector&lt;int&gt; entradasRestantes(vertices.size());
    queue&lt;int&gt; caja;

    for(int v = 0; v &lt; vertices.size(); v++) {
        entradasRestantes[v] = vertices[v].gradoDeEntrada;
        if (entradasRestantes[v] == 0)
            caja.push(v);
    }

    int anyo = 1;
    int simultaneas = caja.size();

    while (!caja.empty()) {
        int v = caja.front();
        caja.pop();

        cout &lt;&lt; &quot;Asignatura: &quot; &lt;&lt; v &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;anyo &quot; &lt;&lt; anyo &lt;&lt; endl;

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
            if(--entradasRestantes[arco-&gt;vecino] == 0)
                caja.push(arco-&gt;vecino);

        if (!caja.empty() &amp;&amp; --simultaneas == 0) {
            anyo++;
            simultaneas = caja.size();
        }
    }

    return anyo;
}</code></pre><p id="f018ea61-225b-46e5-a1e8-e5ad4d7ec4b5" class="">
</p><blockquote id="aaff3b2f-c6fa-41a4-9834-67d388064a7c" class="block-color-gray"><em>Este ejercicio tiene mucha importancia, ya que no enseña la forma de recorrer un árbol que no es necesariamente conexo. Para solucionar eso metemos todo en un bucle for que iterara sobre todos los vértices, de esta forma no nos dejaremos ninguno aunque esté separado de la búsqueda en anchura que estemos haciendo. Para mantener la eficiencia se comprueba siempre si hemos visitado o no el vértice que vamos a mirar. Esta estructura que, con un for y una comprobación de visitados vamos recorriendo todos los vértices del grafo superficialmente veremos que también la usa la búsqueda en profundidad, excepto por su forma de buscar internamente, que es radicalmente diferente.</em></blockquote><p id="fc532ea6-3719-4c97-9e7f-ce30bea853c3" class="block-color-blue">Contar Picaduras</p><pre id="da25c698-357d-4e04-b729-f29b3762bd58" class="code"><code>int GrafoNoDirigido::contarPicaduras() const {

    vector&lt;bool&gt; contagiado(vertices.size(), false);
    queue&lt;int&gt; cola;

    int picaduras = 0;

    for (int origen = 0; origen &lt; vertices.size(); origen++)
        if (!contagiado[origen]) {
            contagiado[origen] = true;
            cola.push(origen);
            picaduras++;

            while(!cola.empty()) {
                int v = cola.front();
                cola.pop();
                for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente)
                    if(!contagiado[arco-&gt;vecino]) {
                        contagiado[arco-&gt;vecino] = true;
                        cola.push(arco-&gt;vecino);
                    }
            }
        }

    return picaduras;
}</code></pre></details></li></ul><ul id="f6237552-7efb-4bda-83ce-94b0d46fe35b" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Dijkstra y Prim</strong></summary><blockquote id="80bdd2a9-2df5-41bd-a067-cc939a406601" class="block-color-gray"><em>El algoritmo de Dijkstra y Prim funcionan de la misma forma excepto por tres diferencias: En Dijkstra el vértice origen es un dato de entrada, con Prim podemos elegir un vértice cualquiera. La implementación de Prim no se puede simplificar eliminando la instrucción que comprueba si el vecino está todavía en la cola de prioridad. En el algoritmo de Dijkstra los pesos de los arcos se van sumando para obtener los pesos de los caminos, mientras que Prim no realiza esta suma.</em></blockquote><p id="8a7b7b29-3cf5-4fd2-86aa-6b51ab0c0048" class="block-color-blue">Traza Dijkstra</p><p id="1f92d9d5-2545-4ee1-9b42-867d851a55f5" class="">
</p><p id="bc7ea797-1c49-4676-9f34-ff62e811fef9" class="block-color-blue">Traza Prim</p><p id="4c586ef0-7f5d-40c6-aff4-f30430f73840" class="">
</p><p id="816cef87-abf8-41f9-9f8a-14a0890eb044" class="block-color-blue">Caminos Óptimos con pesos mediante Dijkstra</p><pre id="377fc770-5477-47be-a9af-f2cc10c55d1d" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;int&gt; GrafoNoDirigido::arbolDeCaminosOptimosConPesos(int origen) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; padre(vertices.size(), -1);

    padre[origen] = -2;
    pesoCaminoOptimo[origen] = 0;
    
    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            float nuevoPeso = pesoCaminoOptimo[v] + arco-&gt;peso;
            if (nuevoPeso &lt; pesoCaminoOptimo[arco-&gt;vecino]) {
                pesoCaminoOptimo[arco-&gt;vecino] = nuevoPeso;
                padre[arco-&gt;vecino] = v;
                pq.cambiarPrioridad(arco-&gt;vecino, nuevoPeso);
            }
        }
    }

    return padre;
}</code></pre><p id="85da8e4b-4585-4cac-a62c-0dc0a47d12c5" class="">
</p><p id="134ccfd5-dbbc-4be6-879a-c84c5f771ff4" class="block-color-blue">Recubrimiento Óptimo mediante Prim</p><pre id="691031e2-53f5-4789-ae39-9f37458ea0d6" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;int&gt; GrafoNoDirigido::arbolDeRecubrimientoOptimo() const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; padre(vertices.size(), -1);
    vector&lt;bool&gt; estaEnLaColaDePrioridad(vertices.size(), true);

    padre[0] = -2;
    pesoCaminoOptimo[0] = 0;
    
    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
        estaEnLaColaDePrioridad[v] = false;

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            if (estaEnLaColaDePrioridad[arco-&gt;vecino]) {
                float nuevoPeso = arco-&gt;peso;
                if (nuevoPeso &lt; pesoCaminoOptimo[arco-&gt;vecino]) {
                    pesoCaminoOptimo[arco-&gt;vecino] = nuevoPeso;
                    padre[arco-&gt;vecino] = v;
                    pq.cambiarPrioridad(arco-&gt;vecino, nuevoPeso);
                }
            }
        }
    }

    return padre;
}</code></pre><p id="60d32675-821d-47a3-89c3-61b59c59b0a4" class="">
</p><p id="0113974c-12ae-4f68-a599-987d5a3c1b54" class="block-color-blue">Destinos Válidos</p><pre id="c05ffab0-a8bc-4844-96ea-a5e0f2561947" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;bool&gt; GrafoDirigido::destinosValidos(int origen, int energia) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);
    vector&lt;bool&gt; resultado(vertices.size(), false);
    vector&lt;float&gt; caminoPesosOptimo(vertices.size(), INFINITO);

    caminoPesosOptimo[origen] = energia;
    resultado[origen] = true;

    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, caminoPesosOptimo[v]);    

    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
    
        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente) {
            int energiaRestante = caminoPesosOptimo[v] - arco-&gt;peso;
            if (energiaRestante &gt;= 0){
                caminoPesosOptimo[arco-&gt;vecino] = energiaRestante;
                pq.cambiarPrioridad(arco-&gt;vecino, energiaRestante);
                resultado[arco-&gt;vecino] = true;
            }
        }
    }

    return resultado;
}</code></pre><p id="537b7548-129b-41fb-a601-522caf260802" class="">
</p><p id="da1aa22e-d871-416f-91a2-f5bb1db588bd" class="block-color-blue">Mostrar Ambulancias</p><pre id="4621f589-dd8a-4283-957f-5b1034134eca" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
void GrafoDirigido::mostrarAmbulancias(int destino,
                                       int ambulanciasNecesarias,
                                       const vector&lt;int&gt; &amp; ambulancias) const {

    vector&lt;int&gt; tiempoMinimo(vertices.size(), INFINITO);
    ColaDePrioridadDecrementable pq(vertices.size() - 1);
    
    tiempoMinimo[destino] = 0;

    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, tiempoMinimo[v]);    

    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
        
        if (tiempoMinimo[v] == INFINITO) {
            cout &lt;&lt; &quot;Si hay mas ambulancias no pueden llegar&quot; &lt;&lt; endl;
            return;
        }
        
        if (ambulancias[v] != -1) {
            cout &lt;&lt; &quot;Elegida ambulancia &quot; &lt;&lt; ambulancias[v];
            cout &lt;&lt; &quot; (tiempo de llegada estimado: &quot; &lt;&lt; tiempoMinimo[v] &lt;&lt; &quot;)&quot;&lt;&lt; endl; 
            if (--ambulanciasNecesarias == 0) {
                cout &lt;&lt; &quot;Conseguidas las ambulancias necesarias&quot; &lt;&lt; endl;
                return;
            }
        }

        for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente) {
            int vecino = arco-&gt;vecino;
            float nuevoTiempo = tiempoMinimo[v] + arco-&gt;peso;
            if (nuevoTiempo &lt; tiempoMinimo[vecino]) {
                tiempoMinimo[vecino] = nuevoTiempo;
                pq.cambiarPrioridad(vecino, nuevoTiempo);
            }
        }
    }
    cout &lt;&lt; &quot;No hay mas ambulancias&quot; &lt;&lt; endl;
}</code></pre><p id="e6ccbe8c-ecb9-40fa-ae6c-18b1f06c793d" class="">
</p><p id="e754001b-589b-414b-8d03-1ead2145b644" class="block-color-blue">Contar Caminos Óptimos</p><pre id="9278e6c3-430c-4815-ae84-034c18dae97a" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
int GrafoNoDirigido::contarCaminosOptimos(int origen, int destino) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; contadorCaminosOptimos(vertices.size(), 0);

    pesoCaminoOptimo[origen] = 0;
    contadorCaminosOptimos[origen] = 1;

    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
        cout &lt;&lt; &quot; Elegido:  &quot; &lt;&lt; v &lt;&lt; endl;

        if (v == destino)
            return contadorCaminosOptimos[v];

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            int vecino = arco-&gt;vecino;
            float nuevoPeso = pesoCaminoOptimo[v] + arco-&gt;peso;
            if (nuevoPeso &lt; pesoCaminoOptimo[vecino]) {
                pesoCaminoOptimo[vecino] = nuevoPeso;
                contadorCaminosOptimos[vecino] = contadorCaminosOptimos[v];
                pq.cambiarPrioridad(vecino, nuevoPeso);
            } else if (nuevoPeso == pesoCaminoOptimo[vecino])
                contadorCaminosOptimos[vecino] += contadorCaminosOptimos[v];
            cout &lt;&lt; &quot;   Vecino: &quot; &lt;&lt; vecino &lt;&lt; &quot;\t&quot; &lt;&lt; pesoCaminoOptimo[vecino];
            cout &lt;&lt; &quot;\t&quot; &lt;&lt; contadorCaminosOptimos[vecino] &lt;&lt; endl;
        }
    }

    return 0;
}</code></pre></details></li></ul><ul id="124e75a7-69a8-423a-aac7-53a6bad589c5" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Búsqueda en profundidad</strong></summary><p id="eedbfad4-d5e0-4ba6-a07c-e752d5ca2b05" class="">
</p><p id="21ccb6de-9246-47b2-86fc-2b36ba7baaeb" class="block-color-blue">Contar Picaduras</p><pre id="252984d5-17e1-41e4-b8a9-b4ae6b9d191c" class="code"><code>int GrafoNoDirigido::contarPicaduras() const {
    
    vector&lt;bool&gt; contagio(vertices.size(), false);
    int picaduras = 0;

    for (int v = 0; v &lt; vertices.size(); v++)
        if (!contagio[v]) {
            picaduras++;
            contarPicaduras(contagio, v);
        }

    return picaduras; 
}

void GrafoNoDirigido::contarPicaduras(vector&lt;bool&gt; &amp; contagio,
                                     int v) const {

    contagio[v] = true;

    for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente)
        if (!contagio[arco-&gt;vecino])
            contarPicaduras(contagio, arco-&gt;vecino);
}</code></pre><p id="32b5db16-b940-4940-ba1e-e688a5f3de6a" class="block-color-blue">Es Alcanzable</p><pre id="e4e239ce-3a7c-4686-8f2d-14cbd2d8cea5" class="code"><code>bool GrafoDirigido::esAlcanzable(vector&lt;bool&gt; &amp; visitado, int destino, int v) const{
    
    if (v == destino)
        return true;
    
    visitado[v] = true;

    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
        if (!visitado[arco-&gt;vecino])
            if (esAlcanzable(visitado, destino, arco-&gt;vecino))
                return true;
    return false;
}

bool GrafoDirigido::esAlcanzable(int origen, int destino) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);

    return esAlcanzable(visitado, destino, origen);    
}</code></pre><p id="aae4c540-2e87-4a2a-b7ee-c89c1244e42a" class="">
</p><blockquote id="57c2be38-af59-43d0-a6b3-23092f617e9a" class="block-color-gray"><em>La solución eficiente de este ejercicio pasa por iniciar el recorrido en el vértice donde está el queso y recorrer el grafo a través de sus vértices de entrada hasta alcanzar o no a todos los ratones</em></blockquote><p id="f4dd8a3b-95a5-4f44-a936-4aa198549a69" class="block-color-blue">Queso Alcanzable por todos los ratones</p><pre id="8cca769f-5247-4cf4-83c0-5d4d70d7eae7" class="code"><code>// Version recursiva
bool GrafoDirigido::buscarRatones(int v,
                                  const vector&lt;bool&gt; &amp; raton,
                                  int &amp; cantidadDeRatonesPorVisitar,
                                  vector&lt;bool&gt; &amp; visitado) const {
    if (raton[v] &amp;&amp; --cantidadDeRatonesPorVisitar == 0)
        return true;

    visitado[v] = true;
    
    for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
        if(!visitado[arco-&gt;vecino])
            if (buscarRatones(arco-&gt;vecino, raton, cantidadDeRatonesPorVisitar, visitado))
                return true;

    return false;
}

bool GrafoDirigido::quesoAlcanzablePorTodosLosRatones(int queso, const vector&lt;bool&gt; &amp; raton) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    int cantidadDeRatonesPorVisitar = 0;

    for (int v = 0; v &lt; vertices.size(); v++)
        if (raton[v])    
            cantidadDeRatonesPorVisitar++;

    if (cantidadDeRatonesPorVisitar == 0)
        throw string (&quot;Faltan los ratones&quot;);

    return buscarRatones(queso, raton, cantidadDeRatonesPorVisitar, visitado);    
}

// Version Iterativa
bool GrafoDirigido::quesoAlcanzablePorTodosLosRatones(int queso, 
                                    const vector&lt;bool&gt; &amp; raton) const {
    int cantidadDeVertices = vertices.size();

    vector&lt;bool&gt; visitado(cantidadDeVertices, false);
    queue&lt;int&gt; cola;

    int cantidadDeRatonesPorVisitar = 0;

    for (int v = 0; v &lt; cantidadDeVertices; v++)
        if (raton[v])
            cantidadDeRatonesPorVisitar++;
    
    if (cantidadDeRatonesPorVisitar == 0)
        throw string (&quot;Faltan los ratones&quot;);
    
    if (raton[queso] &amp;&amp; --cantidadDeRatonesPorVisitar == 0)
        return true;
    
    visitado[queso] = true;
    cola.push(queso);

    while(!cola.empty()) {
        int v = cola.front();
        cola.pop();
        for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
            if (!visitado[arco-&gt;vecino]) {
                if (raton[arco-&gt;vecino] &amp;&amp; --cantidadDeRatonesPorVisitar == 0)
                    return true;
                visitado[arco-&gt;vecino] = true;
                cola.push(arco-&gt;vecino);
            }
    }
    
    return true;
}</code></pre><p id="501867fc-60da-409f-a327-a17d3d6b48f3" class="">
</p><p id="48d08c91-11e2-48b1-b7d6-78eea91ea1d9" class="block-color-blue"><a href="https://en.wikipedia.org/wiki/Kosaraju&#x27;s_algorithm">Traza Kosaraju-Sharir</a> para averiguar componentes <a href="https://es.wikipedia.org/wiki/Componente_fuertemente_conexo">Fuertemente Conexas</a></p><p id="767391cb-c9fa-4376-acc3-97fbf8034ddd" class="">
</p><blockquote id="1f473cc9-a237-44fc-9419-6ab8755005a0" class="block-color-gray"><em>Hacemos uso del algoritmo de Kosaraju-Sharir para averiguar componentes Fuertemente Conexas</em></blockquote><p id="e437598c-93a8-4060-bf7e-7e54b8426731" class="block-color-blue">Colorear Conectados</p><pre id="46302628-d3a1-4270-840d-a1b0e4ebf46f" class="code"><code>#define SIN_COLOR -1
void GrafoDirigido::KosarajuSharirEtapa2DFS(int v, 
                                            vector&lt;int&gt; &amp; colores, 
                                            int color) const {
    colores[v] = color;
    for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
        if (colores[arco-&gt;vecino] == SIN_COLOR)
            KosarajuSharirEtapa2DFS(arco-&gt;vecino, colores, color);
}

void GrafoDirigido::KosarajuSharirEtapa1DFS(int v, 
                                            vector&lt;bool&gt; &amp; visitado,
                                            stack&lt;int&gt; &amp; pila) const {
    visitado[v] = true;
    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
        if (!visitado[arco-&gt;vecino])
            KosarajuSharirEtapa1DFS(arco-&gt;vecino, visitado, pila);    
    pila.push(v);
}

vector&lt;int&gt; GrafoDirigido::colorearConectados() const {
    
    vector&lt;bool&gt; visitado(vertices.size(), false);
    vector&lt;int&gt; colores(vertices.size(), SIN_COLOR);
    stack&lt;int&gt; pila;
    int color = 0, origen;

    for (origen = 0; origen &lt; vertices.size(); origen++) {
        if (!visitado[origen])
            KosarajuSharirEtapa1DFS(origen, visitado, pila);
    }
    
    while (!pila.empty()) {
        int origen = pila.top();
        pila.pop();
        if (colores[origen] == SIN_COLOR)
            KosarajuSharirEtapa2DFS(origen, colores, ++color);
    }    

    return colores;
}</code></pre><p id="ed383cf9-f485-429e-a638-b3b3d4485408" class="block-color-blue">
</p><p id="1d762bec-3b91-4f27-810a-3909cef369c8" class="block-color-blue">Repartir Islas</p><pre id="825aacc5-6b73-4ac5-860c-9b22a1bdceb4" class="code"><code>#define SIN_EQUIPO -1
void GrafoNoDirigido::repartirIslasBFS(int v, 
                                       int e,
                                       vector&lt;int&gt; &amp; equipo) const {
    e = e == 1 ? 2 : 1;
    equipo[v] = e;

    for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
        if (equipo[arco-&gt;vecino] == SIN_EQUIPO) {
            repartirIslasBFS(arco-&gt;vecino, e, equipo);
        } else if (equipo[v] == equipo[arco-&gt;vecino])
            throw string(&quot;No existe solucion: el grafo no es bipartido&quot;);
    }
}

// Repartir islas para que cada una pertenezca a un equipo y solo a uno
// No haya dos islas conectadas por un puente asignadas la mismo equipo
vector&lt;int&gt; GrafoNoDirigido::repartirIslas() const {
    
    vector&lt;int&gt; equipo(vertices.size(), SIN_EQUIPO);

    for (int v = 0; v &lt; vertices.size(); v++)
        if (equipo[v] == SIN_EQUIPO)
            repartirIslasBFS(v, 2, equipo);    

    return equipo;
}</code></pre><p id="deaa6585-d0ec-4a89-9560-8e1d8102659b" class="block-color-blue">
</p><p id="13578c68-70ab-4c4f-b3f1-741c6b5a3bb8" class="block-color-blue">Orden Topológico</p><pre id="7fbc2dd6-fc69-4561-a5ee-39cfee5243f7" class="code"><code>void GrafoDirigido::obtenerOrdenTopologicoDFS(int v, 
                                              vector&lt;bool&gt; &amp; visitado, 
                                              stack&lt;int&gt; &amp; pila) const {
    visitado[v] = true;
    
    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
        if (!visitado[arco-&gt;vecino])
            obtenerOrdenTopologicoDFS(arco-&gt;vecino, visitado, pila);

    pila.push(v);
}

void GrafoDirigido::mostrarOrdenTopologico() const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    stack&lt;int&gt; pila;

    for (int v = 0; v &lt; vertices.size(); v++)
        if (vertices[v].gradoDeEntrada == 0)    
            obtenerOrdenTopologicoDFS(v, visitado, pila);


    while (!pila.empty()) {
        int v = pila.top();
        pila.pop();
        cout &lt;&lt; &quot;  --&gt; &quot; &lt;&lt;  v &lt;&lt; endl;
    }
}</code></pre><p id="8e7b349c-3df8-4e62-9d48-32358d6f731c" class="block-color-blue">
</p><p id="ed898453-7e01-4246-9214-e921a89af4b2" class="block-color-blue">Aciclicidad</p><pre id="4e7c391e-2a77-4695-9686-6db7ad0350f7" class="code"><code>bool GrafoDirigido::buscarCicloDFS(int v, 
                                   vector&lt;int&gt; &amp; estado) const {

    estado[v] = 1;

    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente) {
        if (estado[arco-&gt;vecino] == 1)
            return true;
        if (estado[arco-&gt;vecino] == 0)
            if (buscarCicloDFS(arco-&gt;vecino, estado))
                return true;
    }
    
    estado[v] = 2;
    
    return false;
}


bool GrafoDirigido::esAciclico() const {
    // Estado 0: No visitado
    // Estado 1: Ha iniciado la busqueda pero no ha terminado
    // Estado 2: Ha sido visitado
    vector&lt;int&gt; estado(vertices.size(), 0);
    
    for (int v = 0; v &lt; vertices.size(); v++)
        if (estado[v] == 0)
            if (buscarCicloDFS(v, estado))
                return false;

    return true;
}</code></pre></details></li></ul><p id="80419861-0202-42a4-9cfa-a57a179547f2" class="">
</p></div></article></body></html>