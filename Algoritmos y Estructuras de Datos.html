<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Algoritmos Resumen General</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1b9f3017-20ec-4d63-96d6-99fd95d9bcbd" class="page sans"><header><img class="page-cover-image" src="https://c.tenor.com/r9gRUQerG48AAAAd/vladimir-putin-putin.gif" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">üìö</span></div><h1 class="page-title">Algoritmos Resumen General</h1></header><div class="page-body"><p id="3719cac8-1f83-4585-b44b-8ab93c50729e" class="">
</p><h3 id="5a31728d-785f-4549-87c2-c57a9e3260c7" class="block-color-blue_background"> TEMA 1</h3><ul id="ecef1d7c-3280-4363-b99a-4f53b3d8cd83" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Costes</strong></summary><blockquote id="d41c5875-9456-4fa5-bbe3-87c816ea11ec" class="block-color-gray"><em>Costes Cola de Prioridad</em></blockquote><table id="a50289dd-d68d-4d2a-bc8e-87e39a207026" class="simple-table"><tbody><tr id="08ee5dc4-58aa-4b49-809a-b6768462ba23"><td id="OEoe">Cola de Prioridad</td><td id="Kh[\">Insertar</td><td id="tvLx">Eliminar M√≠nmo</td><td id="n:Tw">Consultar M√≠nimo</td></tr><tr id="194409d4-37ac-4a47-a1e6-335bc10a14cf"><td id="OEoe">vector no ordenado</td><td id="Kh[\">O(1)</td><td id="tvLx">O(n)</td><td id="n:Tw">O(1)</td></tr><tr id="e820ef15-44ba-49ac-b233-b7a3a7efb22e"><td id="OEoe">vector ordenado</td><td id="Kh[\">O(n)</td><td id="tvLx">O(1)</td><td id="n:Tw">O(1)</td></tr><tr id="b7ccbc62-3330-4f3e-9675-77fa20cae9bd"><td id="OEoe">lista enlazada no ordenada</td><td id="Kh[\">O(1)</td><td id="tvLx">O(n)</td><td id="n:Tw">O(1)</td></tr><tr id="61d3c086-65bd-4068-8b74-7da40679c2c5"><td id="OEoe">lista enlazada ordenada</td><td id="Kh[\">O(n)</td><td id="tvLx">O(1)</td><td id="n:Tw">O(1)</td></tr></tbody></table><blockquote id="1fce67ca-ab36-4c58-ae28-c9ebbf23d397" class="block-color-gray"><em>Costes Conjunto y Multi-Conjunto</em></blockquote><table id="0b5fae74-4813-4ce2-89df-ba5d5cc9fc6a" class="simple-table"><tbody><tr id="77353547-2bdd-4afd-8fb9-175ffb8e41b4"><td id="`Ou^">Conjunto</td><td id="|FZf">Insertar</td><td id="c^qv">Eliminar</td><td id="KcTd">Buscar</td></tr><tr id="8d89f536-6ba8-4782-91a8-8187979988c0"><td id="`Ou^">vector no ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(1)</td></tr><tr id="b8b2cb81-b4be-45d0-b243-577d623a6090"><td id="`Ou^">vector ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(log n)</td></tr><tr id="f1fee4a7-f1d3-40b9-848a-7000484d67d8"><td id="`Ou^">lista enlazada no ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr><tr id="b88ce96f-e857-48d5-a3e5-b3695816b61e"><td id="`Ou^">lista enlazada ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr></tbody></table><table id="7dad3cb1-376e-434a-bcfa-47c623c2b947" class="simple-table"><tbody><tr id="badc2e70-3601-4aeb-85a4-a0d4b05f1fd3"><td id="`Ou^">Multi-Conjunto</td><td id="|FZf">Insertar</td><td id="c^qv">Eliminar</td><td id="KcTd">Buscar</td></tr><tr id="16832cf5-a7e8-4496-8f10-be5bb9b3cced"><td id="`Ou^">vector no ordenado</td><td id="|FZf">O(1)</td><td id="c^qv">O(n)</td><td id="KcTd">O(1)</td></tr><tr id="a2909c40-37ee-4ce6-a0d1-35ee1191dfd9"><td id="`Ou^">vector ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(log n)</td></tr><tr id="fb0f0cd2-c539-4960-942a-5d9aabfaebdb"><td id="`Ou^">lista enlazada no ordenada</td><td id="|FZf">O(1)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr><tr id="157d3192-5c67-4878-b5d4-29e50133b52d"><td id="`Ou^">lista enlazada ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr></tbody></table><p id="a5a7fca9-193f-4b06-8201-724a4c815d84" class="">
</p><blockquote id="db3fee31-ccd9-45d6-ae6c-cd3cada03703" class="block-color-gray"><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA5.1/solucion_coste_temporal_Huffman.html"><em>Huffman implementado en varias estructuras de datos</em></a></blockquote><table id="8aab093f-1cc6-425d-8930-5e51e78612c2" class="simple-table"><tbody><tr id="8d9a7324-b869-4aa8-910c-f30c46ff8226"><td id="?ecC"></td><td id="W{[\">Inserci√≥n de N datos</td><td id="E[TW">Dos operaciones de eliminar m√≠nimo N veces</td><td id="`_Nk">Una operaci√≥n de inserci√≥n N veces</td></tr><tr id="49bbba3a-44f1-4642-a489-d1e71af1b5b6"><td id="?ecC">Vector no ordenado</td><td id="W{[\">O (n)</td><td id="E[TW">O (n)</td><td id="`_Nk">O (n^2)</td></tr><tr id="845c1216-a4b1-4884-bc7d-d38c35581f34"><td id="?ecC">Vector ordenado</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n)</td><td id="`_Nk">O (n^2)</td></tr><tr id="f8756f1c-1be4-4faf-8ca7-41abd05dda5d"><td id="?ecC">√Årbol binario de b√∫squeda</td><td id="W{[\">O (n^2) </td><td id="E[TW">O (n^2)</td><td id="`_Nk">O (n^2)</td></tr><tr id="34199eb7-6594-404f-97c3-66c2f4cf2ef8"><td id="?ecC">√Årbol de AVL</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr><tr id="4618a21b-1aca-46ea-8bdc-b79e8d7950fb"><td id="?ecC">Mont√≠culo binario</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr><tr id="07841dcb-a558-4031-90f1-202535e13b40"><td id="?ecC">Mont√≠culo de Fibonacci</td><td id="W{[\">O (n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr></tbody></table><p id="3f425ff9-b187-4e79-99ad-967c5aae56e1" class="">
</p><blockquote id="b036edf4-8100-41ae-99c6-ea99f201286a" class="block-color-gray"><em>Dijkstra y Prim </em><em><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/grafos.html#ejercicios6b">(Ejercicio 13 Tema 6.5)</a></em></blockquote><p id="1f4b4037-ecef-48bd-b8f8-11e0698c5789" class="">
</p></details></li></ul><h3 id="17ac309e-ffab-4e05-9b8c-fa66790d7a14" class="block-color-blue_background"> TEMA 2</h3><ul id="866fb524-f16d-4de6-8355-4f484f8f4f47" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Colas de Prioridad</strong></summary><blockquote id="96dd3169-cae3-4673-a8e4-ab962790421e" class="block-color-gray"><em>Estudia la implementaci√≥n de la clase Cola y la clase Pila. Es importante entender lo que se ha hecho para conseguir los costes O(1) y en que se diferencia. A√±ade a la implementaci√≥n de cola estos m√©todos:</em></blockquote><p id="6a17f066-2c1d-4917-9208-e18c58ddaaa7" class="block-color-blue">Buscar</p><pre id="4df96f44-69f8-493c-a439-07e9205f4b05" class="code"><code>// Buscar iterativo
bool Cola::buscar(int n) const {
    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente)
        if(actual-&gt;dato == n)
            return true;
    
    return false;
}

// Buscar recursivo
bool Cola::buscarRecursivo(int n, Nodo * actual) const {
    if (actual == nullptr)
        return false;

    if (actual-&gt;dato == n)
        return true;
    
    return buscarRecursivo(n, actual-&gt;siguiente);
}

bool Cola::buscarRecursivo(int n) const {
    buscarRecursivo(n, primero);
}</code></pre><p id="a3b3b418-b587-403d-9298-1bde00b0910f" class="block-color-blue">Buscar Posicion</p><pre id="fdfbd5d3-78f6-4f73-93e7-cf65581c3a4f" class="code"><code>// BuscarPosicion Iterativo
int Cola::buscarPosicion(int n) const {
    int posicion = 0;

    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente, posicion++)
        if(actual-&gt;dato == n)
            return posicion;

    return -1; 
}

//Buscar posiciones Recursivo
int Cola::buscarPosicionRecursivo(int n, Nodo * actual, int posicion) const{
    
    if(actual == nullptr)
        return -1;
    if(actual-&gt;dato == n)
        return posicion;
        
    return buscarPosicionRecursivo(n, actual-&gt;siguiente, posicion + 1);;
}

int Cola::buscarPosicionRecursivo(int n) const {   
    buscarPosicionRecursivo(n, primero, 0);
}</code></pre><p id="6d55fe4d-ec3f-471a-baa0-78591661418a" class="block-color-blue">Colas Iguales</p><pre id="72d5f033-08a5-4bc4-9f7c-1115eec170e7" class="code"><code>// ColasIguales Iterativo
bool Cola::colasIguales(const Cola &amp; cola) const {
    
    Nodo * actual = primero;
    Nodo * actualCola = cola.primero;

    while (actual != nullptr &amp;&amp; actualCola != nullptr) {
        if(actual-&gt;dato != actualCola-&gt;dato)
            return false;
        actual = actual-&gt;siguiente;
        actualCola = actualCola-&gt;siguiente;
    }

    return actual == nullptr &amp;&amp; actualCola == nullptr;
}

// ColasIguales Recursivo
bool Cola::colasIgualesRecursivo(Nodo * actual, Nodo * actualCola) const {

    if (actual == nullptr &amp;&amp; actualCola == nullptr)
        return true;
    
    if (actual == nullptr || actualCola == nullptr)
        return false;

    return actual-&gt;dato == actualCola-&gt;dato 
				&amp;&amp; colasIgualesRecursivo(actual-&gt;siguiente, actualCola-&gt;siguiente);
}

bool Cola::colasIgualesRecursivo(const Cola &amp; cola) const {
    colasIgualesRecursivo(primero, cola.primero);
}</code></pre><p id="15baa6d0-92e1-49bc-806d-a67f45b3acf7" class="block-color-blue">Eliminar</p><pre id="3b206303-611a-47fd-b85e-59391204bd6d" class="code"><code>// Eliminar Iterativo
void Cola::eliminar(int n) {
    if (primero == nullptr)
        throw string(&quot;Intentando eliminar un elemento de una cola vac√≠a&quot;);
    
    Nodo * anterior = primero;
    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente) {
        if (actual-&gt;dato == n) {
            if (actual == ultimo)
                ultimo = anterior;
            if (actual == primero)
                primero = primero-&gt;siguiente;
            else
                anterior-&gt;siguiente = actual-&gt;siguiente;
            delete actual;
        }
        anterior = actual;
    }    
}

// Eliminar Recursivo
void Cola::eliminarRecursivo(int n, Nodo * &amp; actual, Nodo * anterior) {
    if (actual == nullptr)
        return;
    
    if(actual-&gt;dato == n) {
        Nodo * basura = actual;
        anterior-&gt;siguiente = actual-&gt;siguiente;
        delete basura;
        if (actual == nullptr)
            ultimo = anterior;
    }
    else 
        eliminarRecursivo(n, actual-&gt;siguiente, anterior);
}

void Cola::eliminarRecursivo(int n) {
    eliminarRecursivo(n, primero, primero);
}</code></pre></details></li></ul><ul id="23f7bf7b-2430-4a95-a5af-08f8f71d6eb1" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Lista doblemente enlazada</strong></summary><blockquote id="8ec68d42-3c8f-4301-afca-fc75397c3398" class="block-color-gray"><em>Una cola de prioridad de doble fin permite: insertar un elemento que tiene una cierta prioridad, extraer un elemento de minima prioridad y extraer un elemento de m√°xima prioridad. A estos hay que a√±adirles ciertos m√©todos que deben funcionar en los tiempos indicados:</em></blockquote><p id="a0bd76b3-7f94-4c29-af49-1062d54ca783" class="block-color-blue">Insertar</p><pre id="48bb595c-1935-464e-90b3-c496dd6cd46c" class="code"><code>// Insertar
void ColaDePrioridadDeDobleFin::insertar(int prioridad) {
    
    laTalla++;
    if (minimo == nullptr)
        minimo = maximo = new Nodo(prioridad, nullptr, nullptr);
    else if(prioridad &lt;= minimo-&gt;prioridad) {
        minimo = new Nodo(prioridad, nullptr, minimo);
        minimo-&gt;anterior-&gt;siguiente = minimo;
    } else if(prioridad &gt;= maximo-&gt;prioridad) {
        maximo = new Nodo(prioridad, maximo, nullptr);
        maximo-&gt;siguiente-&gt;anterior = nuevo;
    } else  {
        for(Nodo * actual = minimo; actual != nullptr, actual = actual -&gt;siguiente) {
            if(actual-&gt;dato == d) {
                Nodo * nuevo = new Nodo(prioridad, actual-&gt;anterior, actual)
                actual-&gt;anterior-&gt;siguiente = nuevo;
                actual-&gt;anterior = nuevo; 
                return;
            }
        }
    }
}</code></pre><p id="72775b1b-6d26-42a2-973a-a7411cb95359" class="block-color-blue">Eliminar</p><pre id="303dbc50-7610-4f44-8293-05d782310f45" class="code"><code>// Eliminar
void ColaDePrioridadDeDobleFin::eliminar(int prioridad) {
    for(Nodo * actual = minimo; actual != nullptr, actual = actual -&gt;siguiente) { 
        if (actual-&gt;prioridad == prioridad) {
            if(minimo == maximo)
                minimo = maximo = nullpter
            else if(prioridad == minimo-&gt;prioridad) {
                minimo = minimo-&gt;siguiente;
                minimo-&gt;anterior = nullptr;
            } else if (prioridad == maximo-&gt;prioridad) {
                maximo = maximo-&gt;anterior;
                minimo-&gt;siguiente = nullptr;
            } else {
                actual-&gt;anterior-&gt;siguiente = actual-&gt;siguiente;
                actual-&gt;siguiente-&gt;anterior = actual-&gt;anterior;
            }
            delete actual;
            laTalla--;
            return;
        }
    }
}</code></pre><p id="feac6119-6684-4e55-8828-58e25f6e6c84" class="block-color-blue">Vaciar</p><pre id="bc1878cf-61fa-457b-8245-21d7ddee6452" class="code"><code>// Vaciar
void ColaDePrioridadDeDobleFin::vaciar() const {
    Nodo * basura;
    while(minimo != nullptr) {
        basura = minimo;
        minimo = minimo-&gt;siguiente;
        delete basura;
    } 

    minimo = maximo = nullptr;
    laTalla = 0;
}</code></pre><p id="6a468f55-e2e8-4d84-9530-07af996e9e42" class="block-color-blue">Unir ‚ÜíO(a + b)</p><pre id="24634afa-5d4f-48a7-a496-6e9bcca227b0" class="code"><code>// Unir
void ColaDePrioridadDeDobleFin::unir(const ColaDeProiridadDeDobleFin &amp; cola1, const ColaDeProiridadDeDobleFin &amp; cola2) {
    Nodo * actualCola1 = cola1-&gt;primero;
    Nodo * actualCola2 = cola2-&gt;segundo;
    vaciar();
    laTalla = 0;

    while (actualCola1 != nullptr &amp;&amp; actualCola2 != nullptr) {
        if (actualCola1-&gt;priodidad &lt;= actualCola2-&gt;prioridad) {
            insertar(actualCola1-&gt;prioridad);
            actualCola1 = actualCola1-&gt;siguiente;
        }
        else {
            insertar(actualCola1-&gt;prioridad);
            actualCola2 = actualCola2-&gt;siguiente;
        }
        laTalla++;
    }

    while (actualCola1 != nullptr) {
        insertar(actualCola1-&gt;prioridad);
        actualCola1 = actualCola1-&gt;siguiente;
        laTalla++;
    }

    while (actualCola2 != nullptr) {
        insertar(actualCola2-&gt;prioridad);
        actualCola2 = actualCola2-&gt;siguiente;
        laTalla++;
    }
}</code></pre><p id="1e3756fe-4433-41a5-8f43-d500fc623ba8" class="">
</p></details></li></ul><h3 id="e944bf87-ab68-4e03-87a7-0498a3dfb600" class="block-color-blue_background"> TEMA 3</h3><ul id="75a658db-3624-43be-a317-9faec812cc92" class="block-color-gray_background toggle"><li><details open=""><summary><strong>√Årbol binario de b√∫squeda</strong></summary><blockquote id="2ff16b97-5adc-4b83-8513-2ca2e5b948dd" class=""><em>Partiendo de la versi√≥n inicial de la implementaci√≥n del TAG Conjunto:</em></blockquote><p id="fa3e15ae-cb91-4fd1-8d00-9f9ea6ca5399" class="block-color-blue">Sumar</p><pre id="be22a81e-395a-417e-8885-9ea6f703d7d1" class="code"><code>
int Conjunto::sumar() const {
    return sumar(raiz);
}

int Conjunto::sumar(Nodo * actual) const {
    if (actual == nullptr)
        return 0;
    return actual-&gt;dato + sumar(actual-&gt;izquierdo) + sumar(actual-&gt;derecho);
}
</code></pre><p id="29729005-9179-430d-b2da-347915d65ec5" class="">
</p><p id="6e4b802b-e6e2-4eea-b0bf-3d61fa8ffb80" class="block-color-blue">Incrementar Todos</p><pre id="ac93d57e-7f1a-41da-aec1-38d35743679a" class="code"><code>void Conjunto::incrementarTodos() {
    incrementarTodos(raiz);
}

void Conjunto::incrementarTodos(Nodo * actual) {
    if (actual == nullptr)
        return;
    actual-&gt;dato++;
    incrementarTodos(actual-&gt;izquierdo);
    incrementarTodos(actual-&gt;derecho);
}</code></pre><p id="ad94c192-837a-46d3-b4fd-80db1ae8a187" class="">
</p><p id="38241b31-45de-4b88-a070-9381d5a85099" class="block-color-blue">Mostrar Ordenados</p><pre id="68d327c5-3663-43a1-b341-39026c753220" class="code"><code>void Conjunto::mostrarOrdenados() const {
    cout &lt;&lt; &quot;[&quot;;
    mostrarOrdenados(raiz);
    cout &lt;&lt; &quot;]&quot;;
}

void Conjunto::mostrarOrdenados(Nodo * actual) const {
    if (actual != nullptr) {
        mostrarOrdenados(actual-&gt;izquierdo);
        cout &lt;&lt; actual-&gt;dato &lt;&lt; &quot; &lt; &quot;;
        mostrarOrdenados(actual-&gt;derecho);
    }
}</code></pre><p id="566918f7-5a4b-4654-b40f-e4aa505cf9bb" class="">
</p><p id="80e90ca5-debe-4b49-8ce0-59d5a5e669db" class="block-color-blue">Obtener Ordenados</p><pre id="dced472e-068f-49cb-9e45-891da8b7ea15" class="code"><code>vector&lt;int&gt; Conjunto::obtenerOrdenados() const {
    vector&lt;int&gt; vectorOrdenados(laTalla);
    int i = 0;
    obtenerOrdenados(vectorOrdenados, raiz, i);
    return vectorOrdenados;
}

void Conjunto::obtenerOrdenados(vector&lt;int&gt; vectorOrdenados, Nodo * actual, int i) const {
    if (actual != nullptr) {
        obtenerOrdenados(vectorOrdenados, actual-&gt;izquierdo, i);
        vectorOrdenados[i++] = actual-&gt;dato;
        obtenerOrdenados(vectorOrdenados, actual-&gt;derecho, i);
    }
}</code></pre><p id="87f4c06a-356b-45e8-a31f-140575ba9614" class="">
</p><p id="08a0a7e1-8f28-4290-9f60-c333240c0455" class="block-color-blue">Buscar</p><pre id="d2de33f0-8783-463f-ac0e-e056822c427b" class="code"><code>bool Conjunto::buscar(int dato) const {
    return buscar(dato, raiz);
}

bool Conjunto::buscar(int dato, Nodo * actual) const {
    if (actual == nullptr)
        return false;
    if(actual-&gt;dato &gt; dato)
        buscar(dato, actual-&gt;izquierdo);
    if(actual-&gt;dato &lt; dato)
        buscar(dato, actual-&gt;derecho);

    return false;
}</code></pre><p id="8c4b3fcb-ee78-4959-b030-477de3d1b7f5" class="">
</p><p id="59d2d24d-cc4c-44fb-838b-f6eb91c2029a" class="block-color-blue">Insertar</p><pre id="f25276a9-055e-4aaa-bf53-0e22c3c99df3" class="code"><code>void Conjunto::insertar(int dato) {
    Nodo * actual = raiz;
    while (actual != nullptr) {
        if(dato == actual-&gt;dato) // No insertamos duplicados
            return; 
        else if(dato &lt; actual-&gt;dato)
            actual = actual-&gt;izquierdo;
        else
            actual = actual-&gt;derecho;
            
    }
    actual = new Nodo(dato);
    laTalla++;
}</code></pre><p id="4fb61196-5c7a-4dc6-9a24-5f066e1778f9" class="">
</p><p id="91e8f8f2-64e9-4414-b6d4-d4651cb1487b" class="block-color-blue">Vaciar</p><pre id="fcbce1ed-5b59-46dd-a60e-8d620434a293" class="code"><code>void Conjunto::vaciar() {
    vaciar(raiz);
    laTalla = 0;
    raiz = nullptr;
}

void Conjunto::vaciar(Nodo * actual) {
    if(actual != nullptr) {
        vaciar(actual-&gt;izquierdo);
        vaciar(actual-&gt;derecho);
        delete actual;
    }
}</code></pre><p id="148ac595-7523-4c27-88fb-53190a26fccc" class="">
</p><p id="19499116-9725-4f22-8559-3af84b711ce0" class="block-color-blue">Es √Årbol Binario de B√∫squeda</p><pre id="e498a118-2e54-48ff-b284-4ebee1f88805" class="code"><code>bool Conjunto::esArbolBinarioDeBusqueda() const {
    vector&lt;int&gt; vectorArbol(laTalla);
    int i = 0;
    obtenerOrdenados(vectorArbol, raiz, i);

    for (i = 1; i &lt; laTalla; i++)
        if (vectorArbol[i - 1] &gt; vectorArbol[i])
            return false;\
    return true;        
}</code></pre></details></li></ul><ul id="0bf42290-3086-4f5a-8aa1-8dd4d505f19b" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Diccionarios</strong></summary><blockquote id="565c9fba-a81e-4211-b725-e8cbebfadfdd" class="block-color-gray"><em>Esta implementaci√≥n del TAD Diccionario permite almacenar datos de tipo entero con claves de tipo cadena, empleando internamente un √°rbol binario de b√∫squeda. Estos tres m√©todos son los mismos que ten√≠amos en el TAD Conjunto pero modificados ligeramente para convertirlo en una implementaci√≥n del TAD Diccionario que use internamente un √°rbol binario de b√∫squeda</em></blockquote><p id="ebf9fa13-afbd-45a1-b826-9f0f3c061464" class="block-color-blue">Insertar</p><pre id="9d8819cd-f956-435a-acd9-6043c9830fe5" class="code"><code>void Diccionario::insertar(const string &amp; unaClave, int unDato) {
    insertar(unaClave, unDato, raiz);
}

void Diccionario::insertar(const string &amp; unaClave, int unDato, Nodo * &amp; n) {
    if (n == nullptr) {
        n = new Nodo(unaClave, unDato);
        if (minimo == nullptr || unDato &lt; minimo-&gt;dato);
            minimo = n;
        laTalla++;
    }
    else if (unaClave &lt; n-&gt;clave)
        insertar(unaClave, unDato, n-&gt;izquierdo);
    else if (unaClave &gt; n-&gt;clave)
        insertar(unaClave, unDato, n-&gt;derecho);
    // No insertamos duplicados
}</code></pre><p id="0244311c-6a3a-45ab-95a2-8731958a407a" class="">
</p><p id="68669070-6415-4ea3-a372-8ea45dcc029d" class="block-color-blue">Eliminar</p><pre id="592e6bff-9f76-4b07-a167-d1cf6e0be087" class="code"><code>void Diccionario::eliminar(const string &amp; unaClave) {
    eliminar(unaClave, raiz);
}

void Diccionario::eliminar(const string &amp; unaClave, Nodo * &amp; n) {
    if (n == nullptr)
        return;
    if (unaClave &lt; n-&gt;clave)
        eliminar(unaClave, n-&gt;izquierdo);
    else if(unaClave &gt; n-&gt;clave)
        eliminar(unaClave, n-&gt;derecho);
    else if (n-&gt;izquierdo != nullptr &amp;&amp; n-&gt;derecho != nullptr) {
        Nodo * nodoMinimo = minimoEnSubarbol(n-&gt;derecho);
        n-&gt;dato = nodoMinimo-&gt;dato;
        n-&gt;clave = nodoMinimo-&gt;clave;
        eliminar(n-&gt;clave, n-&gt;derecho);
    } else {
        Nodo * basura = n;
        if (n-&gt;izquierdo != nullptr)
            n = n-&gt;izquierdo;
        else 
            n = n-&gt;derecho;
        if (basura == minimo)
            if (raiz != nullptr)
                minimo = minimoEnSubarbol(raiz);
            else 
                minimo = nullptr;
        delete basura;
        laTalla--;
    }
}</code></pre><p id="9b9ee6b6-8db8-4a6a-8900-792a85afe29c" class="">
</p><p id="c48718d0-57b9-44cd-96f7-e0d58fb55c15" class="block-color-blue">Buscar</p><pre id="c271099c-e06f-4d49-a5af-ec1ad5db3050" class="code"><code>int &amp;  Diccionario::buscar(const string &amp; unaClave) const {
    return buscar(unaClave, raiz);
}

int &amp;  Diccionario::buscar(const string &amp; unaClave, Nodo * actual) const {
    if (actual == nullptr)
        throw string(&quot;No existe ningun elemento en el diccionario con la clave buscada.&quot;);
    if (unaClave &lt; actual-&gt;clave)
        buscar(unaClave, actual-&gt;izquierdo);
    if (unaClave &gt; actual-&gt;clave)
        buscar(unaClave, actual-&gt;derecho);
    return actual-&gt;dato;
}</code></pre></details></li></ul><ul id="7d004dcb-5ddc-47d2-b0dd-70e8ff45fea7" class="block-color-gray_background toggle"><li><details open=""><summary><strong>M√©todos √°rboles</strong></summary><p id="de4f8f4b-d482-4606-900b-b1102b77d9a3" class="block-color-blue">Altura Arbol</p><pre id="e81b8c5c-9ae5-4202-8f81-eff301a7dcb5" class="code"><code>int Conjunto::altura() const {
    return altura(raiz);
}

int Conjunto::altura(Nodo * actual) const {
    if (actual == nullptr)
        return -1;
    return 1 + max(altura(actual-&gt;izquierdo), altura(actual-&gt;derecho));
}</code></pre><p id="4ed6f76a-d20f-45fb-873f-51cda65a80f0" class="block-color-blue">No Hay Hijo Sin Hermano</p><pre id="d1e174c0-b56f-42cd-a5b7-f0538403939b" class="code"><code>bool Conjunto::noHayHijoSinHermano() const {
    return raiz == nullptr || noHayHijoSinHermano(raiz);
}

bool Conjunto::noHayHijoSinHermano(Nodo * actual) const {
    if(actual-&gt;izquierdo == nullptr &amp;&amp; actual-&gt;derecho == nullptr)
        return true;
    if(actual-&gt;izquierdo != nullptr &amp;&amp; actual-&gt;derecho != nullptr)
        return noHayHijoSinHermano(actual-&gt;izquierdo) &amp;&amp; noHayHijoSinHermano(actual-&gt;derecho);
    return false;
}</code></pre><blockquote id="87184829-64a0-45b2-a099-594f3e40b7c3" class="">S<em>e hace especial √©nfasis en la forma en la que la recursividad puede solucionar estos problemas de manera eficiente</em></blockquote><p id="570411f2-240a-444d-b0f7-e87da51c5411" class="block-color-blue">Arboles Iguales</p><pre id="6bf1e62c-218b-4859-8935-c4f8bdbac83e" class="code"><code>bool Conjunto::arbolesIguales(const Conjunto &amp; otroConjunto) const {
    return arbolesIguales(raiz, otroConjunto.raiz);
}

bool Conjunto::arbolesIguales(Nodo * n1, Nodo * n2) const {

    if (n1 == nullptr &amp;&amp; n2 == nullptr)
        return true;
    if (n1 != nullptr || n2 != nullptr)
        return false;
    if (n1-&gt;dato != n2-&gt;dato)
        return false;
    return arbolesIguales(n1-&gt;izquierdo, n2-&gt;izquierdo)
            &amp;&amp; arbolesIguales(n1-&gt;derecho, n2-&gt;derecho);    
}</code></pre><blockquote id="56652746-e9a2-4888-8a2f-9f1912559699" class=""><em>Este ejercicio es una introducci√≥n b√°sica a una manera en la que se pueden recorrer los √°rboles en anchura. Esta estrategia se repetir√° en algunos ejercicios del tema de grafos.</em></blockquote><p id="da2ba3bd-8d84-4adb-8b14-57252520b202" class="block-color-blue">Mostrar Por Nivel</p><pre id="dd07cf30-303c-4ec5-833a-13728abfcb76" class="code"><code>void Conjunto::mostrarPorNiveles() const {
    queue&lt;Nodo *&gt; nodosAMostrar;

    if (raiz != nullptr) {
        nodosAMostrar.push(raiz);
        int nivel = 1;
        mostrarPorNiveles(nodosAMostrar);
    }
}

void Conjunto::mostrarPorNiveles(queue&lt;Nodo *&gt; nodosAMostrar) const {
    if (!nodosAMostrar.empty()) {
        Nodo * actual = nodosAMostrar.front();
        cout &lt;&lt; &quot;Dato: &quot; &lt;&lt; actual &lt;&lt; endl;
        nodosAMostrar.pop();
        if(actual-&gt;izquierdo != nullptr)
            nodosAMostrar.push(actual-&gt;izquierdo);
        if(actual-&gt;derecho != nullptr)
            nodosAMostrar.push(actual-&gt;derecho);
        mostrarPorNiveles(nodosAMostrar);
    }
}</code></pre><blockquote id="9caabde0-3e46-4dc4-b306-8661e366e8c3" class=""><em>Estructura completa de la manera correcta de recorrer un √°rbol por niveles. Hay </em><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA3/Conjunto_verificarProfundidad.html"><em>varias formas</em></a><em> de solucionar este ejercicio: con la implementaci√≥n de un struct Pair donde se guardara la profundidad del nodo, usando una cola y manteniendo un contador de la talla de cada nivel, una pila de pares...</em></blockquote><p id="08aa2019-dce6-4fa0-8fc3-079d1428d675" class="block-color-blue">Verificar Profundidad</p><pre id="d77b00ab-6210-4d62-bdf7-98bd396b15d6" class="code"><code>// Verificar Profundidad Recursivo
bool Conjunto::verificarProfundidadR(int profundidad) const {
    verificarProfundidadR(raiz, profundidad);
}

bool Conjunto::verificarProfundidadR(Nodo * actual, int profundidad) const {
    if (actual == nullptr)
        return false;
    
    if (profundidad == 0)
        return true;
    
    return verificarProfundidadR(actual-&gt;izquierdo, profundidad - 1) 
        ||  verificarProfundidadR(actual-&gt;derecho, profundidad - 1);
}

// Verificar Profundidad Iterativo
bool Conjunto::verificarProfundidad(int profundidad) const {
    if (raiz == nullptr)
        return;

    if (profundidad == 0)
        return;

    queue&lt;Nodo *&gt; cola;
    cola.push(raiz);
    int tallaPorNivel = cola.size();

    while(!cola.empty()) {     
        Nodo * n = cola.front();
        cola.pop();

        if (n-&gt;izquierdo != nullptr) {
            if (profundidad == 0)
                return true;
            cola.push(n-&gt;izquierdo);
        }
        if (n-&gt;derecho != nullptr) {
            if (profundidad == 0)
                    return true;
            cola.push(n-&gt;derecho);
        }

        if (--tallaPorNivel == 0) {
            tallaPorNivel = cola.size();
            profundidad -= 1;
        }
    }

    return false;
}</code></pre></details></li></ul><ul id="0c1986eb-ba8e-49e1-97da-99fa8a9b059f" class="block-color-gray_background toggle"><li><details open=""><summary><strong>AVL</strong></summary><p id="f8cca665-b32c-4542-9041-a9ce4989a7f7" class="">
</p></details></li></ul><h3 id="742247c6-f0f6-4329-935f-648cb7e914da" class="block-color-blue_background"> TEMA 4</h3><ul id="fb90062e-f29e-4d7f-ac6a-2380226d7380" class="block-color-gray_background toggle"><li><details open=""><summary>Huffman</summary><blockquote id="21097456-80bb-4f46-97c3-0292d0bb7245" class="block-color-gray"><em>Implementar el constructor de la clase Huffman y m√©todos para codificar y decodificar. </em><strong><a href="https://es.wikipedia.org/wiki/Algoritmo_de_Huffman#Descripci.C3.B3n"><em>Explicaci√≥n</em></a></strong></blockquote><blockquote id="3beab4b6-b00d-40d6-ba34-e48193d69f44" class="block-color-gray"><em>Los costes en el algoritmo de Huffman van a depender de la estructura interna con que decidamos implementarlo: vector ordenado, AVL, mont√≠culo binario...</em></blockquote><p id="7028473e-12f6-489f-9eb1-f98bdc9023e3" class="block-color-blue">Constructor</p><pre id="448e22d9-1e0a-48b4-b9b8-1ba71269c2ea" class="code"><code>Huffman::Huffman(const vector&lt;pair&lt;char, float&gt;&gt; &amp; frecuencias) : raiz{nullptr} {

    if (frecuencias.size() &lt; 2)
        throw string(&quot;Necesitamos al menos dos caracteres con sus frecuencias&quot;);

    class ComparadorNodos {
    public:
        bool operator() (Nodo* nodo1, Nodo* nodo2) const {
            return nodo1-&gt;frecuencia &gt; nodo2-&gt;frecuencia;
        }
    };

    priority_queue&lt;Nodo *, vector&lt;Nodo *&gt;, ComparadorNodos&gt; colaDePrioridad;

    for (const auto caracter : frecuencias) {
        Nodo * nuevo = new Nodo(caracter.first, caracter.second);
        colaDePrioridad.push(nuevo);
        hojas.emplace(caracter.first, nuevo);
    }

    while(colaDePrioridad.size() &gt; 1) {        
        Nodo* n = new Nodo(&#x27; &#x27;, 0);
        n-&gt;izquierdo = colaDePrioridad.top();
        colaDePrioridad.pop();
        n-&gt;derecho = colaDePrioridad.top();
        colaDePrioridad.pop();

        n-&gt;frecuencia = n-&gt;izquierdo-&gt;frecuencia + n-&gt;derecho-&gt;frecuencia;

        n-&gt;izquierdo-&gt;padre = n;
        n-&gt;izquierdo-&gt;bit = &#x27;0&#x27;;

        n-&gt;derecho-&gt;padre = n;
        n-&gt;derecho-&gt;bit = &#x27;1&#x27;;

        colaDePrioridad.push(n);
    }

    raiz = colaDePrioridad.top();
}</code></pre><p id="5bdf0641-fae5-4d70-ba59-a431688a072c" class="block-color-blue">Codificar</p><pre id="0f00ae41-59e4-4d90-847f-dc1f4a257923" class="code"><code>string Huffman::codificar(const string &amp; mensajeACodificar) const {

    string mensajeCodificado, caracterCodificado;
    Nodo * n;
    for (char caracter : mensajeACodificar) {
        try {
            n = hojas.at(caracter);
        } catch (out_of_range error) {
            throw string(&quot;El mensaje a codificar contiene algun caracter que no estaba &quot;)
                + string(&quot;en la tabla de frecuencias inicial (&quot;) + caracter + &quot;).&quot;;
        }

        caracterCodificado = &quot;&quot;;
        while(n != raiz) {
            caracterCodificado += n-&gt;bit;
            n = n-&gt;padre;
        }
        reverse(caracterCodificado.begin(), caracterCodificado.end());
        mensajeCodificado += caracterCodificado;
    }

    return mensajeCodificado;
}</code></pre><p id="44afd5c1-0896-4cdc-8312-387c357095c7" class="block-color-blue">Decodificar</p><pre id="a4671bed-1d75-4384-86d4-ac20379a6062" class="code"><code>string Huffman::decodificar(const string &amp; mensajeADecodificar) const {

    string mensajeDecodificado;
    Nodo * actual = raiz;
    for (char bitMensaje : mensajeADecodificar) {
        if(bitMensaje == &#x27;0&#x27;)
            actual = actual-&gt;izquierdo;
        else
            actual = actual-&gt;izquierdo;

        if (actual-&gt;izquierdo == nullptr) {
            mensajeDecodificado += actual-&gt;caracter;
            actual = raiz;
        }
    }
    return mensajeDecodificado;
}</code></pre></details></li></ul><h3 id="ff3e3419-d7ce-4ef5-93e2-4ca5d0e06076" class="block-color-blue_background"> TEMA 5</h3><ul id="358fadba-5da0-45a2-a3fa-b35fc7d51a95" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Divide y vencer√°s (Closest Points)</strong></summary><blockquote id="5f598c08-db50-4fa3-a9cf-d5fc49073901" class=""><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA5.2/ClosestPoints_ayuda.html"> Ayuda V</a>. <a href="https://es.wikipedia.org/wiki/Problema_del_par_de_puntos_m%C3%A1s_cercanos#Algoritmo_recursivo_en_el_plano_2D">Ayuda Wikipedia</a></blockquote><pre id="53cc50d3-4371-4d3b-8de2-b2215487df45" class="code"><code>typedef pair&lt;float, float&gt; Punto;

void ver(const vector&lt;Punto&gt; &amp; puntos) {
    for (const auto &amp; p : puntos)
        cout &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot; )&quot;;
}

bool compararY(const Punto &amp; p1, const Punto &amp; p2) {
    return p1.second &lt; p2.second;
}

float distanciaAlCuadrado(const Punto &amp; p1, const Punto &amp; p2) {
    float a = p2.first - p1.first;
    float b = p2.second - p1.second;
    return a * a + b * b;
}

float distanciaAlCuadradoMinima(const vector&lt;Punto&gt; &amp; puntosPorX, const vector&lt;Punto&gt; &amp; puntosPorY) {
    // Caso base de la recursion
    int talla = puntosPorX.size();
    if (talla == 2)
        return distanciaAlCuadrado(puntosPorX[0], puntosPorX[1]);

    if (talla == 3)
        return min({distanciaAlCuadrado(puntosPorX[0], puntosPorX[1]),
                    distanciaAlCuadrado(puntosPorX[0], puntosPorX[2]),
                    distanciaAlCuadrado(puntosPorX[1], puntosPorX[2])});
    
    // Dividimos los vectores en dos mitades
    int tallaIzquierda = talla / 2;

    vector&lt;Punto&gt; mitadIzqX(puntosPorX.begin(), puntosPorX.begin() + tallaIzquierda);
    vector&lt;Punto&gt; mitadDerX(puntosPorX.begin() + tallaIzquierda, puntosPorX.end());
    
    // Dividimos el vector Y en dos mitades. 
    // O(n) gracias a las mitades ordenadas del vector X
    vector&lt;Punto&gt; mitadIzqY(tallaIzquierda);
    vector&lt;Punto&gt; mitadDerY(talla - tallaIzquierda);

    for (int i = 0, j = 0, k = 0; i &lt; talla; i++)
        if (puntosPorY[i] &lt; mitadDerX[0]) // A igual X mira Y, no pueden coincidir X e Y
            mitadIzqY[j++] = puntosPorY[i];
        else
            mitadDerY[k++] = puntosPorY[i];

    // Llamamos a la funcion recursiva pasandole los puntos de la mitad izquierda
    float minimaIzq = distanciaAlCuadradoMinima(mitadIzqX, mitadIzqY);

    // Llamamos a la funcion recursiva pasandole los puntos de la mitad derecha
    float minimaDer = distanciaAlCuadradoMinima(mitadDerX, mitadDerY); 

    // Creamos un vector con los puntos en la franja central ordenados por Y
    float minima = min(minimaIzq, minimaDer);
    vector&lt;Punto&gt; puntosCentralesPorY;
    float frontera = mitadIzqX[tallaIzquierda - 1].first;
    for (auto punto : puntosPorY)
        if (abs(frontera - punto.first) &lt; minima)
            puntosCentralesPorY.push_back(punto);
   
    // Calculamos distancias entre puntos de la franja central con criterio
    // de parada por distancia vertical
    for (int i = 0; i &lt; puntosCentralesPorY.size() - 1; i++)
        for (int j = i + 1;
            j &lt; puntosCentralesPorY.size() &amp;&amp; puntosCentralesPorY[j].second - puntosCentralesPorY[i].second &lt; minima;
            j++)
            minima = min(minima, distanciaAlCuadrado(puntosCentralesPorY[i], puntosCentralesPorY[j]));
        
    return minima;
}

float distanciaMinima(const vector&lt;Punto&gt; &amp; puntos) {
    // Si tenemos menos de dos puntos paramos
    if (puntos.size() &lt; 2)
        throw string (&quot;Necesitamos al menos dos puntos.&quot;);
    
    // Ordenamos los puntos por X en una copia del vector.
    // Si coinciden se mira la Y
    vector&lt;Punto&gt; ordenadosPorX(puntos);
    sort(ordenadosPorX.begin(), ordenadosPorX.end());

    // Detectamos duplicados
    for (int i = 0; i &lt; ordenadosPorX.size() - 1; i++)
        if (ordenadosPorX[i] == ordenadosPorX[i + 1])
            return 0;    

    // Ordenamos los puntos por Y en una copia del vector
    vector&lt;Punto&gt; ordenadosPorY(puntos);
    sort(ordenadosPorY.begin(), ordenadosPorY.end(), compararY);
    
    // Llamamos a la funcion recursiva pasandole los dos vectores de puntos
    return sqrt(distanciaAlCuadradoMinima(ordenadosPorX, ordenadosPorY));
}</code></pre></details></li></ul><ul id="a3442b0d-d068-4207-9c50-aab1c145a752" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Teorema Maestro (Ejercicio 2 y 8 Divide y vencer√°s V)</strong></summary></details></li></ul><ul id="7666ae97-e6ad-4157-8881-040974c75fb8" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Programaci√≥n Din√°mica </strong><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/estrategias.html#ejercicios53">(Enunciados)</a></summary><ul id="98715258-b1f9-438a-8ab8-e0833bca9614" class="block-color-blue toggle"><li><details open=""><summary>Fibonacci</summary><blockquote id="9824d7ce-2244-4d57-9e59-72d79753dbf2" class="block-color-gray"><em>Ejercicio preliminar para entender el uso de una tabla para guardar resultados y no repetir c√°lculos</em></blockquote><pre id="46edcf14-6204-4320-8d4f-74dfbda480bd" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE 
***************************************************************************/
long long fibonacci(int n) {
    long long resultado
    if (n &lt;= 1)
        resultado = n;
    else
        resultado = fibonacci(n - 1) + fibonacci(n - 2);
    return resultado;
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
long long fibonacci(int n, vector&lt;long long&gt; &amp; resultado) {
    if (resultado[n] == DESCONOCIDO) {
        if (n &lt;= 1)
            resultado[n] = n;
        else 
            resultado[n] = fibonacci(n - 1, resultado) 
                           + fibonacci(n - 2, resultado);
    }
    return resultado[n];
}

long long fibonacci(int n) {
    vector&lt;long long&gt; resultado(n + 1, DESCONOCIDO);
    return fibonacci(n, resultado);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
long long fibonacci(int n) {
    
    long long resultado;

    if (n &lt;= 1)
        resultado = n;
    else {
        long long penultimo = 0, ultimo = 1;
        for (int i = 2; i &lt;= n; i++) {
            resultado = ultimo + penultimo;
            penultimo = ultimo;
            ultmo = resultado;
        }
    }

    return resultado;
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
**************************************************************************/
int main() {
    
    for (int dato = 10; dato &lt;= 50; dato += 5) {
        cout &lt;&lt; &quot;Fibonacci (&quot; &lt;&lt; dato &lt;&lt; &quot;) = &quot;;
        cout &lt;&lt; &quot;\t&quot; &lt;&lt; fibonacci(dato) &lt;&lt; endl;
    }
}</code></pre></details></li></ul><ul id="fa44793a-486f-444d-81ec-4e3a9b0ee5bf" class="block-color-blue toggle"><li><details open=""><summary>Maximo de Puntos en el Escenario</summary><blockquote id="dd4ab0c7-9ff1-485c-a12a-166d989e8611" class="block-color-gray"><em>En este ejercicio, donde se busca conseguir el m√°ximo de puntos desde un origen hasta un destino yendo √∫nicamente hacia la derecha y hacia abajo, se introduce el uso de la funci√≥n max y min, donde recursivamente se suma al resultado la opci√≥n que nos interese m√°s, en este caso el mayor por la derecha o el mayor por abajo. Tambi√©n se cubren las dem√°s posibilidades en las que habr√° una pared o iremos √∫nicamente en una direcci√≥n, que basta con ir sumando resultados recursivamente. El ejercicio tambi√©n se puede resolver al rev√©s, partiendo de la casilla objetivo y yendo hacia arriba y hacia la izquierda.</em></blockquote><pre id="863e0c5b-04ae-4081-9928-04bef346fdcb" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
#define PARED -1
#define DESCONOCIDO -1

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos, 
                int x, 
                int y) {
    int ultimaFila = puntos.size() - 1, ultimaColumna = puntos[0].size() - 1;
    float resultado;

    if (puntos[x][y] == PARED)
        resultado = -INFINITO;
    else if (x ==  ultimaFila &amp;&amp; y == ultimaColumna)
        resultado = puntos[x][y];
    else if (x == ultimaFila)
        resultado = puntos[x][y] + maxPuntos(puntos, resultado, x, y + 1);
    else if (y == ultimaColumna)
        resultado = puntos[x][y] + maxPuntos(puntos, resultado, x + 1, y);
    else
        resultado =  puntos[x][y] + max(maxPuntos(puntos, resultado, x + 1, y),
                                        maxPuntos(puntos, resultado, x, y + 1));

    return resultado;
}

float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos) {
    return maxPuntos(puntos, resultado, 0, 0);
} 

/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos, 
                vector&lt;vector&lt;float&gt;&gt; &amp; resultado, 
                int x, 
                int y) {
                    
    int ultimaFila = puntos.size() - 1;
    int ultimaColumna = puntos[0].size() - 1;
    

    if (resultado[x][y] == DESCONOCIDO) {
        if (puntos[x][y] == PARED)
            resultado[x][y] = -INFINITO;
        else if (x == ultimaFila &amp;&amp; y == ultimaColumna)
            resultado[x][y] = puntos[x][y];
        else if (x == ultimaFila)
            resultado[x][y] = puntos[x][y] + maxPuntos(puntos, resultado, x, y + 1);
        else if (y == ultimaColumna)
            resultado[x][y] = puntos[x][y] + maxPuntos(puntos, resultado, x + 1, y);
        else
            resultado[x][y] =  puntos[x][y] + max(maxPuntos(puntos, resultado, x + 1, y),
                                                  maxPuntos(puntos, resultado, x, y + 1));
    }

    return resultado[x][y];
}

float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos) {
    int cantidadFilas = puntos.size(), cantidadColumnas = puntos[0].size();
    vector&lt;float&gt; valorVectorResultado(cantidadColumnas, DESCONOCIDO);

    vector&lt;vector&lt;float&gt;&gt; resultado(cantidadFilas, valorVectorResultado);
    return maxPuntos(puntos, resultado, 0, 0);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float maxPuntos(const vector&lt;vector&lt;float&gt;&gt; &amp; puntos) {

    int ultimaFila = puntos.size() - 1, ultimaColumna = puntos[0].size() - 1;
    vector&lt;vector&lt;float&gt;&gt; resultado(ultimaFila + 1, vector&lt;float&gt;(ultimaColumna + 1));

    for (int fila = ultimaFila; fila &gt;= 0; fila--)

        for (int columna = ultimaColumna; columna &gt;= 0; columna--) 

            if (puntos[fila][columna] == -1)
                resultado[fila][columna] = -INFINITO;

            else if (fila == ultimaFila &amp;&amp; columna == ultimaColumna)
                resultado[fila][columna] = puntos[fila][columna];

            else if (fila == ultimaFila)
                resultado[fila][columna] = puntos[fila][columna] + resultado[fila][columna + 1];

            else if (fila == ultimaFila)
                resultado[fila][columna] = puntos[fila][columna] + resultado[fila][columna];

            else
                resultado[fila][columna] = puntos[fila][columna] + max(resultado[fila][columna + 1],
                                                                       resultado[fila + 1][columna]);
    
    return resultado[0][0];
}


/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main()  {
    vector&lt;vector&lt;float&gt;&gt; ejemplo = {{3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                                     {0,  5,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1,  0,  0},
                                     {0,  0,  0, -1, -1,  1,  3, -1, -1,  0,  0,  0, -1,  0,  0},
                                     {0,  5,  0,  9, -1,  2,  4, -1,  9,  0,  0,  0, -1,  0,  0},
                                     {-1, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1,  0,  5},
                                     {-1, 0,  0,  3,  2, -1, -1,  2,  3,  0,  0,  0, -1,  0,  0},
                                     {-1, 0,  0,  4, -1, -1, -1, -1,  4,  0,  0,  0, -1,  0,  5},
                                     {0,  0,  0, -1, -1, -1, -1, -1, -1,  0,  0,  0, -1,  0,  0},
                                     {7,  0,  0,  1,  1,  1,  1,  1,  1,  0,  0,  0, -1,  0,  5},
                                     {0,  0,  0,  0, -1, -1, -1, -1,  1,  1,  1,  1,  1,  2,  4}};


    float cantidadMaxima = maxPuntos(ejemplo);
    cout &lt;&lt; &quot;Cantidad de puntos maxima: &quot; &lt;&lt; cantidadMaxima &lt;&lt; endl;
    if (cantidadMaxima == 41)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else 
       cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="a404ba36-c197-474a-9518-ad90e35dc462" class="block-color-blue toggle"><li><details open=""><summary>Competici√≥n de Videojuegos</summary><blockquote id="9e2413c9-b457-4dbe-8585-7575e2a9bbb1" class="block-color-gray"><em>Ejercicio de entrenamiento muy similar al anterior. En este caso tendremos que tener cuidado, como siempre, en la condici√≥n en la que debemos elegir entre dos opciones. El truco est√° en si posponer el inscribirnos en un premio o elegir el actual, siendo el siguiente disponible el que nos marca la clase ¬¥partida¬¥ como primer posterior.</em></blockquote><pre id="a0a6daa1-4389-4046-8c26-cd8a9bcf0679" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct Partida {
    int inicio;
    int final;
    float premio;
    int primeraPosterior;
};  


/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float maximoPremio(const vector&lt;Partida&gt; &amp; competicion,
                    int partida) {
    float resultado;

    if (partida == competicion.size() - 1)
        resultado = competicion[partida].premio;
    else if (competicion[partida].primeraPosterior == -1)
        resultado = max(competicion[partida].premio, 
                        maximoPremio(competicion, partida + 1));
    else
        resultado = max(competicion[partida].premio + maximoPremio(competicion, competicion[partida].primeraPosterior),
                         maximoPremio(competicion, partida + 1));

    return resultado;
}

float maximoPremio(const vector&lt;Partida&gt; &amp; competicion) {

    return maximoPremio(competicion, 0);
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float maximoPremio(vector&lt;float&gt; &amp; resultado, 
                   const vector&lt;Partida&gt; &amp; competicion,
                   int partida) {

    if (resultado[partida] == DESCONOCIDO) {
        if (partida == competicion.size() - 1)
            resultado[partida] = competicion[partida].premio;
        else if (competicion[partida].primeraPosterior == -1)
            resultado[partida] = max(competicion[partida].premio, 
                            maximoPremio(resultado, competicion, partida + 1));
        else
            resultado[partida] = max(competicion[partida].premio + maximoPremio(resultado, competicion, competicion[partida].primeraPosterior),
                            maximoPremio(resultado, competicion, partida + 1));
    }

    return resultado[partida];
}

float maximoPremio(const vector&lt;Partida&gt; &amp; competicion) {

    vector&lt;float&gt; resultado(competicion.size(), DESCONOCIDO);

    return maximoPremio(resultado, competicion, 0);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float maximoPremio(const vector&lt;Partida&gt; &amp; competicion) {

    vector&lt;float&gt; resultado(competicion.size());

    for (int partida = competicion.size() - 1; partida &gt;= 0; partida--)
        if (partida == competicion.size() - 1)
            resultado[partida] = competicion[partida].premio;
        else if (competicion[partida].primeraPosterior == -1)
            resultado[partida] = max(competicion[partida].premio,
                                     resultado[partida + 1]);
        else
            resultado[partida] = max(competicion[partida].premio + resultado[competicion[partida].primeraPosterior],
                                     resultado[partida + 1]);

    return resultado[0];
}

/***************************************************************************
* TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;Partida&gt; ejemploCompeticion = {  {10, 14, 7000, 3},
                                            {11, 12, 3000, 2},
                                            {13, 17, 9000, 5},
                                            {15, 17, 5000, 5},
                                            {16, 19, 8000, -1},
                                            {17, 18, 2000, -1}  };


    float resultado = maximoPremio(ejemploCompeticion);
    cout &lt;&lt; &quot;Maximo premio: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 15000)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="aaf56ba1-2af2-4f8d-a0ff-bb64293fab0c" class="block-color-blue toggle"><li><details open=""><summary>Valores de Casas</summary><blockquote id="79694c7b-96c4-4e77-b154-8f8038e5120c" class="block-color-gray"><em>Muy similar al anterior. En este caso se decide entre si posponer el empezar a robar casas o empezar ya pero avanzando, como m√≠nimo, a la segunda que nos encontremos desde donde estamos, ya que los vecinos se avisar√≠an entre ellos y nos detendr√≠an. Si esta condici√≥n la repetimos podemos ver que el posponer robar cubre tambi√©n la decisi√≥n de cuantas casas esperarnos una vez hayamos comenzado a robar.</em></blockquote><pre id="a33b72a0-c074-4e3f-a088-d3bfd9586229" class="code"><code>// COMPLETA LO QUE FALTA

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas,
                         int casa) {
    
    float resultado;
    if (casa &gt;= valoresCasas.size() - 1)
        resultado = valoresCasas[casa];
    else if (casa == valoresCasas.size() - 2)
        resultado = max(valoresCasas[casa], valoresCasas[casa + 1]);

    else
        resultado = max(valoresCasas[casa] + maximoValorRobable(valoresCasas, casa + 2),
                        maximoValorRobable(valoresCasas, casa + 1));

    return resultado;
}


float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas) {

    int primeraCasa = 0;
    return maximoValorRobable(valoresCasas, primeraCasa);
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float maximoValorRobable(vector&lt;float&gt; &amp; resultado,
                         const vector&lt;float&gt; &amp; valoresCasas,
                         int casa) {
    
    if (resultado[casa] == DESCONOCIDO)
        if (casa &gt;= valoresCasas.size() - 1)
            resultado[casa] = valoresCasas[casa];
        else if (casa == valoresCasas.size() - 2)
            resultado[casa] = max(valoresCasas[casa], valoresCasas[casa + 1]);

        else
            resultado[casa] = max(valoresCasas[casa] + maximoValorRobable(resultado, valoresCasas, casa + 2),
                            maximoValorRobable(resultado, valoresCasas, casa + 1));
                            
    return resultado[casa];
}


float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas) {

    vector&lt;float&gt; resultado(valoresCasas.size(), DESCONOCIDO);
    int primeraCasa = 0;
    return maximoValorRobable(resultado, valoresCasas, primeraCasa);
}

/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float maximoValorRobable(const vector&lt;float&gt; &amp; valoresCasas) {
    
    vector&lt;float&gt; resultado(valoresCasas.size());
    int casa;

    for (casa = valoresCasas.size() - 1; casa &gt;= 0; casa--)
        if (casa &gt;= valoresCasas.size() - 1)
            resultado[casa] = valoresCasas[casa];
        else if (casa == valoresCasas.size() - 2)
            resultado[casa] = max(valoresCasas[casa], valoresCasas[casa + 1]);

        else
            resultado[casa] = max(valoresCasas[casa] + resultado[casa + 2],
                                  resultado[casa + 1]);
                            
    return resultado[0];
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    
    vector&lt;float&gt; calleMayor = {6000, 10000, 3000, 15000, 4000, 2000, 8000, 5000};
    vector&lt;float&gt; calleAlta = {3000, 6000, 7000, 5000};

    float resultado = maximoValorRobable(calleAlta);
    cout &lt;&lt; &quot;Maximo valor robable en calle Alta: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 11000)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else   
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
    
    resultado = maximoValorRobable(calleMayor);
    cout &lt;&lt; &quot;Maximo valor robable en calle Mayor: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 33000)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else   
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="fba81691-aa86-423f-b76e-18c45716ab13" class="block-color-blue toggle"><li><details open=""><summary>Coste Colorear Casas</summary><blockquote id="4ce585ba-4185-4ab2-af57-82fbf795410a" class="block-color-gray">Lo m√°s importante que se ve en este ejercicio es la forma en la que elige el m√≠nimo entre varios caminos posibles, con una variable que guardar√° el m√≠nimo y un for que iterar√° entre todas las opciones, qued√°ndonos con la que tenemos guardada en m√≠nimo o la que estamos mirando<em>. Tambi√©n es interesante c√≥mo desde la llama inicial de la recursividad se aprovecha para averiguar cu√°l ser√≠a la casa por la que mas nos merecer√≠a la pena empezar, eligiendo el m√≠nimo entre varias posibilidades como veremos m√°s tarde en el ejercicio de las aldeas (</em>#include &lt;algorithm&gt; // min({ ... })<em>.</em></blockquote><pre id="c7bc1294-0339-4f63-87c5-cafd5032dc24" class="code"><code>// COMPLETA LO QUE FALTA
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // min({ ... })

#include &lt;limits&gt;
#define INFINITO numeric_limits&lt;float&gt;::infinity()

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura,
                         int color,
                         int casa) {
    
    float resultado;

    if (casa == costePintura[0].size() - 1)
        resultado = costePintura[color][casa];
    else {
        float minimo = INFINITO;
        for (int otroColor = 0; otroColor &lt; costePintura.size(); otroColor++)
            if (otroColor != color)
                minimo = min(minimo,
                             costePintura[color][casa] + minimoCostePintura(costePintura, 
                                                                            otroColor, 
                                                                            casa + 1));
        resultado = minimo;
    }
    return resultado;
}

float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura) {

    int casa = 0;
    return min({minimoCostePintura(costePintura, 0, casa),
                minimoCostePintura(costePintura, 1, casa),
                minimoCostePintura(costePintura, 2, casa) });
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePintura(vector&lt;vector&lt;float&gt;&gt; &amp; resultado,
                         const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura,
                         int color,
                         int casa) {

    if (resultado[color][casa] == DESCONOCIDO) {
        if (casa == costePintura[0].size() - 1)
            resultado[color][casa] = costePintura[color][casa];
        else {
            float minimo = INFINITO;
            for (int otroColor = 0; otroColor &lt; costePintura.size(); otroColor++)
                if (otroColor != color)
                    minimo = min(minimo,
                                costePintura[color][casa] + minimoCostePintura(resultado,
                                                                               costePintura, 
                                                                               otroColor, 
                                                                               casa + 1));
            resultado[color][casa] = minimo;
        }
    }
    return resultado[color][casa];
}

float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura) {
    vector&lt;vector&lt;float&gt;&gt; resultado(costePintura.size(), 
                                    vector&lt;float&gt;(costePintura[0].size(), DESCONOCIDO));
    int casa = 0;
    return min({minimoCostePintura(resultado, costePintura, 0, casa),
                minimoCostePintura(resultado, costePintura, 1, casa),
                minimoCostePintura(resultado, costePintura, 2, casa) });
}

/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePintura(const vector&lt;vector&lt;float&gt;&gt; &amp; costePintura) {

    int numeroCasas = costePintura[0].size();
    vector&lt;vector&lt;float&gt;&gt; resultado(3, vector&lt;float&gt;(numeroCasas));

    for (int casa = 0; casa &lt; numeroCasas; casa++)
        for (int color = 0; color &lt; 3; color++)
            if (casa == 0)
                resultado[color][casa] = costePintura[color][casa];
            else {
                float minimo = INFINITO;
                for (int otroColor = 0; otroColor &lt; 3; otroColor++)
                    if (otroColor != color)
                        minimo = min(minimo,
                                     costePintura[color][casa] + resultado[otroColor][casa - 1]);
                resultado[color][casa] = minimo;
            }
    
    return min({resultado[0][numeroCasas - 1],
                resultado[1][numeroCasas - 1],
                resultado[2][numeroCasas - 1]});
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    
    vector&lt;vector&lt;float&gt;&gt; ejemploCostePintura = { {300,  600,  200, 1000, 1500, 500, 900},
                                                  {400,  1600, 400, 700,  1200, 400, 200},
                                                  {500,  1300, 600, 100,  300,  500, 800} };

    float resultado = minimoCostePintura(ejemploCostePintura);
    cout &lt;&lt; &quot;Minimo coste pintura: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 3300)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else   
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="0e343242-ef49-43a5-99af-4a5453dbee8b" class="block-color-blue toggle"><li><details open=""><summary>R√≠o Aldeas</summary><blockquote id="267c5da3-bb25-42dc-866f-376494142251" class="block-color-gray"><em>En este ejercicio hay que vigilar los casos de fin de la recursi√≥n y tener cuidado con lo que debemos devolver. Se puede resolver el ejercicio empezando desde la aldea origen o desde la aldea destino.</em></blockquote><pre id="9314c4fa-8fc5-4788-9136-99218d0909c0" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo,
                        int aldea) {

    float resultado;

    int ultimaAldea = paseoCorto.size();
    
    if (aldea == ultimaAldea)
        resultado = 0;    
    else if(aldea == ultimaAldea - 1)
        resultado = paseoCorto[aldea];
    else
        resultado = min(paseoCorto[aldea] + minimoCostePaseo(paseoCorto, paseoLargo, aldea + 1),
                        paseoLargo[aldea] + minimoCostePaseo(paseoCorto, paseoLargo, aldea + 2));

    return resultado;
}

float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo) {
    int primeraAldea = 0;
    return minimoCostePaseo(paseoCorto, paseoLargo, primeraAldea);
}


#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePaseo (vector&lt;float&gt; &amp; resultado,
                        const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo,
                        int aldea) {

    if(resultado[aldea] == DESCONOCIDO) {

        int ultimaAldea = paseoCorto.size();

        if (aldea == ultimaAldea)
            resultado[aldea] = 0;    
        else if(aldea == ultimaAldea - 1)
            resultado[aldea] = paseoCorto[aldea];
        else
            resultado[aldea] = min(paseoCorto[aldea] + minimoCostePaseo(resultado, paseoCorto, paseoLargo, aldea + 1),
                            paseoLargo[aldea] + minimoCostePaseo(resultado, paseoCorto, paseoLargo, aldea + 2));
    }

    return resultado[aldea];
}

float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo) {
    int primeraAldea = 0;
    vector&lt;float&gt; resultado(paseoCorto.size(), DESCONOCIDO);
    return minimoCostePaseo(resultado, paseoCorto, paseoLargo, primeraAldea);
}

/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCostePaseo (const vector&lt;float&gt; &amp; paseoCorto,
                        const vector&lt;float&gt; &amp; paseoLargo) {

    vector&lt;float&gt; resultado(paseoCorto.size() + 1);

    int ultimaAldea = paseoCorto.size();

    for (int aldea = paseoCorto.size(); aldea &gt;= 0; aldea--) 
        if (aldea == ultimaAldea)
            resultado[aldea] = 0;    
        else if(aldea == ultimaAldea - 1)
            resultado[aldea] = paseoCorto[aldea];
        else
            resultado[aldea] = min(resultado[aldea + 1] + paseoCorto[aldea],
                                   resultado[aldea + 2] + paseoLargo[aldea]);

    return resultado[0];
}


/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;float&gt; ejemploPaseoCorto = {80, 20,  60,  50, 90, 10};
    vector&lt;float&gt; ejemploPaseoLargo = {70, 30, 100, 110, 40};

    float resultado = minimoCostePaseo(ejemploPaseoCorto, ejemploPaseoLargo);
    cout &lt;&lt; &quot;Minimo coste paseo: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 200)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="7870ea2d-7122-4106-8945-547626298905" class="block-color-blue toggle"><li><details open=""><summary>R√≠o Aldeas II</summary><blockquote id="1d0fae66-03d2-41cb-9023-d2bff11bc87d" class="block-color-gray"><em>Es un ejercicio parecido a todos los anteriores. De nuevo podemos solucionar el ejercicio partiendo desde el origen o desde el destino. En este caso se usa una variable intento para no tener que usar la funci√≥n min, pero funciona de la misma forma.</em></blockquote><pre id="3e551206-75d7-4d30-97db-075d2a16aa02" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

#include &lt;limits&gt;
#define INFINITO numeric_limits&lt;float&gt;::infinity()

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler,
                  int aldea) {

    float resultado;

    int ultimaAldea = costeAlquiler.size() - 1;
    if (aldea == ultimaAldea)
        resultado = 0;
    else {
        float minimo = INFINITO;
        for (int siguienteAldea = aldea + 1; siguienteAldea &lt; costeAlquiler.size(); siguienteAldea++) {
            float intento = costeAlquiler[aldea][siguienteAldea] + minimoCoste(costeAlquiler, siguienteAldea));
            if (intento &lt; minimo)
                minimo = intento;
        }
        resultado = minimo;
    }

    return resultado;
}

float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler) {
    
    int primerasiguienteAldea = 0;
    return minimoCoste(costeAlquiler, primerasiguienteAldea);
}


#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCoste(vector&lt;float&gt; &amp; resultado,
                  const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler,
                  int aldea) {

    
    if (resultado[aldea] == DESCONOCIDO) {
        int ultimaAldea = costeAlquiler.size() - 1;
        if (aldea == ultimaAldea)
            resultado[aldea] = 0;
        else {
            float minimo = INFINITO;
            for (int siguienteAldea = aldea + 1; siguienteAldea &lt; costeAlquiler.size(); siguienteAldea++) {
                float intento = costeAlquiler[aldea][siguienteAldea] + minimoCoste(resultado, costeAlquiler, siguienteAldea));
                if (intento &lt; minimo)
                    minimo = intento;
            }
            resultado[aldea]  = minimo;
        }
    }

    return resultado[aldea];
}

float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler) {

    vector&lt;float&gt; resultado(costeAlquiler.size(), DESCONOCIDO);
    int primerasiguienteAldea = 0;
    return minimoCoste(resultado, costeAlquiler, primerasiguienteAldea);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
float minimoCoste(const vector&lt;vector&lt;float&gt;&gt; &amp; costeAlquiler) {

    vector&lt;float&gt; resultado(costeAlquiler.size(), DESCONOCIDO);
    
    int ultimaAldea = costeAlquiler.size() - 1;
    for (int aldea = ultimaAldea; aldea &gt;= 0; aldea--) {
        if (aldea == ultimaAldea)
            resultado[aldea] = 0;
        else {
            float minimo = INFINITO;
            for (int siguienteAldea = aldea + 1; siguienteAldea &lt;= ultimaAldea; siguienteAldea++) {
                float intento = resultado[siguienteAldea] + costeAlquiler[aldea][siguienteAldea];
                if (intento &lt; minimo)
                    minimo = intento;
            }
            resultado[aldea]  = minimo;
        }
    }
    
    return resultado[0];
}

/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;vector&lt;float&gt;&gt; ejemplo = {{0, 70, 30, 20, 90},
                                     {0,  0,  0, 60, 10},
                                     {0,  0,  0, 50, 40},
                                     {0,  0,  0,  0, 80},
                                     {0,  0,  0,  0,  0}};
    
    float resultado = minimoCoste(ejemplo);
    cout &lt;&lt; &quot;Coste minimo: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 70)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
    else       
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl;
}</code></pre></details></li></ul><ul id="c87018a0-f922-48cd-8639-bf4b55d1cb3c" class="block-color-blue toggle"><li><details open=""><summary>Cambio de Monedas</summary><blockquote id="6fd24725-2c7d-4a40-b855-e730fbfb92d0" class="block-color-gray"><em>La dificultad de este ejercicio es idear la manera en que controla la deuda restante y c√≥mo va mirando todas las opciones seg√∫n que moneda usar para restar, ya que solo va a tener √©xito si la deuda llega a cero, ni m√°s ni menos, qued√°ndose con el n√∫mero de monedas m√≠nimo.</em></blockquote><pre id="3ca02423-8e07-4254-b507-a53198fcb4a0" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // min({ ... })

using namespace std;

#include &lt;limits&gt;
#define INFINITO numeric_limits&lt;float&gt;::infinity()

/***************************************************************************
 * VERSION 1: RECURSIVA, INEFICIENTE
***************************************************************************/
int minimaCantidadMonedas(const vector&lt;int&gt; &amp; valoresMonedas,
                            int deudaRestante) {
    int resultado;

    if (deudaRestante == 0)
        resultado = 0;
    else {
        int minimo = deudaRestante;
        for (int valor : valoresMonedas)
           if (deudaRestante - valor &gt;= 0)
               minimo = min(minimo,
                            1 + minimaCantidadMonedas(valoresMonedas, deudaRestante - valor));
        resultado = minimo;
    }

    return resultado;    
}

#define DESCONOCIDO -1
/***************************************************************************
 * VERSION 1: RECURSIVA, EFICIENTE
***************************************************************************/
int minimaCantidadMonedas(vector&lt;int&gt; &amp; resultado,
                            const vector&lt;int&gt; &amp; valoresMonedas,
                            int deudaRestante) {
    if (resultado[deudaRestante] == DESCONOCIDO)
        if (deudaRestante == 0)
            resultado[deudaRestante] = 0;
        else {
            int minimo = deudaRestante;
            for (int valor : valoresMonedas)
                if (deudaRestante - valor &gt;= 0)
                    minimo = min(minimo,
                                 1 + minimaCantidadMonedas(resultado, valoresMonedas, deudaRestante - valor));
            resultado[deudaRestante] = minimo;
        }

    return resultado[deudaRestante];    
}

int minimaCantidadMonedas(const vector&lt;int&gt; &amp; valoresMonedas, 
                          int deuda) {
                              
    vector&lt;int&gt; resultado(deuda + 1, DESCONOCIDO);
    return minimaCantidadMonedas(resultado, valoresMonedas, deuda);
}


/***************************************************************************
 * VERSION 3: NO RECURSIVA, EFICIENTE
***************************************************************************/
void mostrarMonedasElegidas(const vector&lt;int&gt; &amp; valoresMonedas,
                            vector&lt;int&gt; &amp; resultado) {

    int deuda = resultado.size() - 1;                                

    while(deuda &gt; 0) 
        for (int valor : valoresMonedas)
            if (deuda - valor &gt;= 0
                &amp;&amp; resultado[deuda] == resultado[deuda - valor] + 1) {
                cout &lt;&lt; &quot;dale &quot; &lt;&lt; valor &lt;&lt; endl;
                deuda -= valor;
                break;
                }
}
int minimaCantidadMonedas(const vector&lt;int&gt; &amp; valoresMonedas, 
                          int deuda) {

    vector&lt;int&gt; resultado(deuda + 1);
    for (int deudaRestante = 0; deudaRestante &lt;= deuda; deudaRestante++) {    
        if (deudaRestante == 0)
            resultado[deudaRestante] = 0;
        else {
            int minimo = deudaRestante;
            for (int valor : valoresMonedas)
                if (deudaRestante - valor &gt;= 0)
                    minimo = min(minimo, 1 + resultado[deudaRestante - valor]);
            resultado[deudaRestante] = minimo;
        }
    }
    mostrarMonedasElegidas(valoresMonedas, resultado);
    return resultado[deuda];    
}


/***************************************************************************
 * TEST (Descomentar todas menos al que queramos probar)
***************************************************************************/
int main() {
    vector&lt;int&gt; monedasMordor =  {5, 21, 1, 25};
    vector&lt;int&gt; monedasPandora = {1,  4, 6, 10};

    int resultado;

    cout &lt;&lt; &quot;Probando monedas de Mordor:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 22&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasMordor, 22);
    cout &lt;&lt;  &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 2)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 63&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasMordor, 63);
    cout &lt;&lt;  &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 3)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Deuda: 65&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasMordor, 65);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 5)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Probando monedas de Mordor:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 22&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasPandora, 22);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 3)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Deuda: 63&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasPandora, 63);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 8)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;Deuda: 65&quot; &lt;&lt; endl;
    resultado = minimaCantidadMonedas(monedasPandora, 65);
    cout &lt;&lt; &quot;Total monedas: &quot; &lt;&lt; resultado &lt;&lt; endl;
    if (resultado == 8)
        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;MAL&quot; &lt;&lt; endl &lt;&lt; endl;
}</code></pre></details></li></ul></details></li></ul><h3 id="27141511-29d2-4c50-8123-e44abd6fcd2b" class="block-color-blue_background"> TEMA 6</h3><ul id="f67c2886-c8ad-4b75-9535-9d654fec48c0" class="block-color-gray_background toggle"><li><details open=""><summary><strong>B√∫squeda en anchura</strong></summary><blockquote id="3a0aabc6-fd90-44aa-b2bf-e5c2fade6471" class="block-color-gray"><em>La estructura es similar a la que se vio en el tema de √°rboles. En este tema recurriremos frecuentemente a un vector de booleanos para comprobar si hemos visitado ya o no el nodo que vamos a mirar. En este caso se usa √∫nicamente el vector de enteros que marca el camino hacia el origen, ya que, si el nodo est√° marcado con un n√∫mero diferente al -1 consideramos que a√∫n no ha sido visitado.                                                                   Para estos ejercicios se hace uso de una clase ColaDePrioridadDecrementable que nos permite cambiar la prioridad de un elemento, eliminar el m√≠nimo, que en esta implementaci√≥n tambi√©n nos lo devuelve y un √∫ltimo m√©todo para insertar.</em></blockquote><p id="91942ab4-1de1-47e7-a6fa-966b24e88d0b" class="block-color-blue">Caminos √ìptimos sin pesos</p><pre id="160df890-a092-49e8-bed2-550970d622f9" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;int&gt; GrafoNoDirigido::arbolDeCaminosOptimosConPesos(int origen) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; padre(vertices.size(), -1);

    padre[origen] = -2;
    pesoCaminoOptimo[origen] = 0;
    
    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            float nuevoPeso = pesoCaminoOptimo[v] + arco-&gt;peso;
            if (nuevoPeso &lt; pesoCaminoOptimo[arco-&gt;vecino]) {
                pesoCaminoOptimo[arco-&gt;vecino] = nuevoPeso;
                padre[arco-&gt;vecino] = v;
                pq.cambiarPrioridad(arco-&gt;vecino, nuevoPeso);
            }
        }
    }

    return padre;
}</code></pre><p id="c5ab2837-b24e-4f6e-94d8-04c6d30d098e" class="">
</p><p id="c494b8b3-2973-4bf7-89b6-d8b959de88eb" class="block-color-blue">Alcanzabilidad</p><pre id="56b82028-0ba3-4278-a44b-e79a2db43ca2" class="code"><code>bool GrafoDirigido::todosAlcanzablesDesdeVertice(int s) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    queue&lt;int&gt; cola;

    visitado[s] = true;
    cola.push(s);
    int contadorVisitados = 1;

    while (!cola.empty()) {
        int v = cola.front();
        cola.pop();

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
            if (visitado[arco-&gt;vecino] == false) {
                visitado[arco-&gt;vecino] = true;
                cola.push(arco-&gt;vecino);
                contadorVisitados++;
            }
    }
    
    return contadorVisitados == vertices.size();
}</code></pre><p id="778f2f56-3ff0-42b1-9339-0fc95b38df43" class="">
</p><blockquote id="c3c6250d-67e7-401c-a4be-6a6b682e46ce" class="block-color-gray"><em>Para ver la conectividad se comprueba √∫nicamente que un origen puede llegar a todos y que, haciendo uso de sus arcos de entrada puede de igual manera visitar todos los nodos. De esta forma solo tendr√° que recorrer el grafo dos veces.</em></blockquote><p id="1e87d579-20d9-4353-a803-eaccee9105a8" class="block-color-blue">Conectividad</p><pre id="eb382f20-b118-4a27-a787-9141834cb49c" class="code"><code>bool GrafoDirigido::verticeAlcanzableDesdeTodos(int s) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    queue&lt;int&gt; cola;

    visitado[s] = true;
    cola.push(s);
    int contadorVisitados = 1;

    while (!cola.empty()) {
        int v = cola.front();
        cola.pop();

        for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
            if (visitado[arco-&gt;vecino] == false) {
                visitado[arco-&gt;vecino] = true;
                cola.push(arco-&gt;vecino);
                contadorVisitados++;
            }
    }
    return contadorVisitados == vertices.size();
}


bool GrafoDirigido::esFuertementeConexo() const {
 
    int origen = 0;
    return todosAlcanzablesDesdeVertice(origen) &amp;&amp; verticeAlcanzableDesdeTodos(origen);
}</code></pre><p id="66d5260b-ce59-4c7e-bbd5-bce2155f9668" class="">
</p><p id="37f60f14-132c-47fc-949d-023a07d7c3df" class="block-color-blue">Ordenaci√≥n Topol√≥gica mediante <a href="https://www.cs.usfca.edu/~galles/visualization/TopoSortIndegree.html">Kahn</a></p><pre id="c9bd5b2a-782e-4ead-8b9a-9b539fe0fa88" class="code"><code>void GrafoDirigido::mostrarOrdenTopologico() const {

    cout &lt;&lt; &quot;Ordenacion topologica: &quot; &lt;&lt; endl;

    vector&lt;int&gt; entradasRestantes(vertices.size());
    vector&lt;int&gt; ordenTopologico(vertices.size());
    queue&lt;int&gt; ceroGrados;
    int contadorDeVertices = 0;

    for (int v = 0; v &lt; vertices.size(); v++) {
        entradasRestantes[v] = vertices[v].gradoDeEntrada;
        if (entradasRestantes[v] == 0)
            ceroGrados.push(v);
    }

    while (!ceroGrados.empty()) {
        int v = ceroGrados.front();
        ceroGrados.pop();
        ordenTopologico[contadorDeVertices++] = v;

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente) {
            if (--entradasRestantes[arco-&gt;vecino] == 0)
                ceroGrados.push(arco-&gt;vecino);
        }
    }
    
    if (contadorDeVertices != vertices.size())
        throw string(&quot;ERROR: el grafo no es aciclico&quot;);

    for (int v : ordenTopologico)
        cout &lt;&lt; v &lt;&lt; endl;
}</code></pre><p id="efddb728-7d64-4cfb-9ea3-c32899b85cdf" class="">
</p><blockquote id="c76a29d5-2065-4c1f-99a9-78d79092ebdd" class="block-color-gray"><em>El algoritmo de Kahn permite resolver si el grafo tiene ciclos o no, mediante el uso de un contador de vertices que comprobara que hemos visitado todos los vertices que tenemos en el grafo, ni m√°s ni menos.</em></blockquote><p id="4e54bc15-8b56-4704-b4cf-c514bf5b5eef" class="block-color-blue">Aciclicidad mediante Kahn</p><pre id="d274aa62-ce9d-4fec-857f-6849c887819b" class="code"><code>bool GrafoDirigido::esAciclico() const {

    vector&lt;int&gt; entradasRestantes(vertices.size());
    queue&lt;int&gt; caja;
    int contadorDeVertices = 0;

    for (int v = 0; v &lt; vertices.size(); v++) {
        entradasRestantes[v] = vertices[v].gradoDeEntrada;
        if (entradasRestantes[v] == 0)
            caja.push(v);
    }

    while (!caja.empty()) {
        int v = caja.front();
        caja.pop();

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
            if (--entradasRestantes[arco-&gt;vecino] == 0)
                caja.push(arco-&gt;vecino);
    }
    
    return contadorDeVertices != vertices.size();
}</code></pre><p id="b2ba7892-0692-4f3c-ac03-9fad6aadcc75" class="">
</p><blockquote id="30860940-0412-4970-aa74-666bc9d7e690" class="block-color-gray"><em>La b√∫squeda en anchura nos permite recorrer el grafo de manera similar a como recorr√≠amos los √°rboles por niveles. En este caso se hace uso de una variable distancia para saber cuando avanzamos de nivel en el grafo, es decir, cuando la distancia de arcos desde el v√©rtice original aumenta. Tambi√©n podr√≠amos hacer uso de un vector de enteros que guardase la informaci√≥n de la distancia de cada v√©rtice y parar cuando se llegue al deseado.</em></blockquote><p id="44526e0c-fbf7-4b22-904a-0fe40719e953" class="block-color-blue">Contar caminos cercanos (M√≠nimos arcos necesarios)</p><pre id="ba2163f0-6ea4-46d4-b9b6-c8304d0b1805" class="code"><code>int GrafoNoDirigido::contarEnemigosCercanos(int islaJugador,
                                            int puentes,
                                            const vector&lt;int&gt; &amp; cantidadEnemigos) const {
    
    vector&lt;bool&gt; visitado(vertices.size(), false);
    vector&lt;int&gt; distancia(vertices.size());
    queue&lt;int&gt; cola;

    distancia[islaJugador] = 0;
    visitado[islaJugador] = true;    
    cola.push(islaJugador);
    int resultado = cantidadEnemigos[islaJugador];


    while (!cola.empty()) {
        int v = cola.front();
        cola.pop();

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente)
            if (!visitado[arco-&gt;vecino]) {
                distancia[arco-&gt;vecino] = distancia[v] + 1;
                visitado[arco-&gt;vecino] = true;
                resultado += cantidadEnemigos[arco-&gt;vecino];
                if (distancia[arco-&gt;vecino] &lt; puentes)
                    cola.push(arco-&gt;vecino);
            }
    }

    return resultado;
}</code></pre><p id="dc0af2fe-013a-46c8-baec-b3a00335ec38" class="">
</p><blockquote id="cde65609-4360-45cf-a422-bca8c6bd0195" class="block-color-gray"><em>Soluci√≥n basada en el algoritmo de Khan, se hace uso de un contador que mantiene actualizada la talla de cada nivel, siempre cuando esta se acaba se actualiza su valor con los v√©rtices que haya almacenados en la cola en ese momento, que no ser√° otro que los que se encuentran en un nivel superior al actual, tal y como lo hac√≠amos con los √°rboles</em></blockquote><p id="a4a5c9b3-533d-4922-b081-97c2bdd5a702" class="block-color-blue">Minima cantidad de A√±os</p><pre id="b19ad33d-4f05-4f16-8bec-688e0404d063" class="code"><code>int GrafoDirigido::minimaCantidadAnyos() const {

    vector&lt;int&gt; entradasRestantes(vertices.size());
    queue&lt;int&gt; caja;

    for(int v = 0; v &lt; vertices.size(); v++) {
        entradasRestantes[v] = vertices[v].gradoDeEntrada;
        if (entradasRestantes[v] == 0)
            caja.push(v);
    }

    int anyo = 1;
    int simultaneas = caja.size();

    while (!caja.empty()) {
        int v = caja.front();
        caja.pop();

        cout &lt;&lt; &quot;Asignatura: &quot; &lt;&lt; v &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;anyo &quot; &lt;&lt; anyo &lt;&lt; endl;

        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
            if(--entradasRestantes[arco-&gt;vecino] == 0)
                caja.push(arco-&gt;vecino);

        if (!caja.empty() &amp;&amp; --simultaneas == 0) {
            anyo++;
            simultaneas = caja.size();
        }
    }

    return anyo;
}</code></pre><p id="f018ea61-225b-46e5-a1e8-e5ad4d7ec4b5" class="">
</p><blockquote id="aaff3b2f-c6fa-41a4-9834-67d388064a7c" class="block-color-gray"><em>Este ejercicio tiene mucha importancia, ya que no ense√±a la forma de recorrer un √°rbol que no es necesariamente conexo. Para solucionar eso metemos todo en un bucle for que iterara sobre todos los v√©rtices, de esta forma no nos dejaremos ninguno aunque est√© separado de la b√∫squeda en anchura que estemos haciendo. Para mantener la eficiencia se comprueba siempre si hemos visitado o no el v√©rtice que vamos a mirar. Esta estructura que, con un for y una comprobaci√≥n de visitados vamos recorriendo todos los v√©rtices del grafo superficialmente veremos que tambi√©n la usa la b√∫squeda en profundidad, excepto por su forma de buscar internamente, que es radicalmente diferente.</em></blockquote><p id="fc532ea6-3719-4c97-9e7f-ce30bea853c3" class="block-color-blue">Contar Picaduras</p><pre id="da25c698-357d-4e04-b729-f29b3762bd58" class="code"><code>int GrafoNoDirigido::contarPicaduras() const {

    vector&lt;bool&gt; contagiado(vertices.size(), false);
    queue&lt;int&gt; cola;

    int picaduras = 0;

    for (int origen = 0; origen &lt; vertices.size(); origen++)
        if (!contagiado[origen]) {
            contagiado[origen] = true;
            cola.push(origen);
            picaduras++;

            while(!cola.empty()) {
                int v = cola.front();
                cola.pop();
                for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente)
                    if(!contagiado[arco-&gt;vecino]) {
                        contagiado[arco-&gt;vecino] = true;
                        cola.push(arco-&gt;vecino);
                    }
            }
        }

    return picaduras;
}</code></pre></details></li></ul><ul id="f6237552-7efb-4bda-83ce-94b0d46fe35b" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Dijkstra y Prim</strong></summary><blockquote id="80bdd2a9-2df5-41bd-a067-cc939a406601" class="block-color-gray"><em>El algoritmo de Dijkstra y Prim funcionan de la misma forma excepto por tres diferencias: En Dijkstra el v√©rtice origen es un dato de entrada, con Prim podemos elegir un v√©rtice cualquiera. La implementaci√≥n de Prim no se puede simplificar eliminando la instrucci√≥n que comprueba si el vecino est√° todav√≠a en la cola de prioridad. En el algoritmo de Dijkstra los pesos de los arcos se van sumando para obtener los pesos de los caminos, mientras que Prim no realiza esta suma.</em></blockquote><p id="8a7b7b29-3cf5-4fd2-86aa-6b51ab0c0048" class="block-color-blue">Traza Dijkstra</p><p id="1f92d9d5-2545-4ee1-9b42-867d851a55f5" class="">
</p><p id="bc7ea797-1c49-4676-9f34-ff62e811fef9" class="block-color-blue">Traza Prim</p><p id="4c586ef0-7f5d-40c6-aff4-f30430f73840" class="">
</p><p id="816cef87-abf8-41f9-9f8a-14a0890eb044" class="block-color-blue">Caminos √ìptimos con pesos mediante Dijkstra</p><pre id="377fc770-5477-47be-a9af-f2cc10c55d1d" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;int&gt; GrafoNoDirigido::arbolDeCaminosOptimosConPesos(int origen) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; padre(vertices.size(), -1);

    padre[origen] = -2;
    pesoCaminoOptimo[origen] = 0;
    
    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            float nuevoPeso = pesoCaminoOptimo[v] + arco-&gt;peso;
            if (nuevoPeso &lt; pesoCaminoOptimo[arco-&gt;vecino]) {
                pesoCaminoOptimo[arco-&gt;vecino] = nuevoPeso;
                padre[arco-&gt;vecino] = v;
                pq.cambiarPrioridad(arco-&gt;vecino, nuevoPeso);
            }
        }
    }

    return padre;
}</code></pre><p id="85da8e4b-4585-4cac-a62c-0dc0a47d12c5" class="">
</p><p id="134ccfd5-dbbc-4be6-879a-c84c5f771ff4" class="block-color-blue">Recubrimiento √ìptimo mediante Prim</p><pre id="691031e2-53f5-4789-ae39-9f37458ea0d6" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;int&gt; GrafoNoDirigido::arbolDeRecubrimientoOptimo() const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; padre(vertices.size(), -1);
    vector&lt;bool&gt; estaEnLaColaDePrioridad(vertices.size(), true);

    padre[0] = -2;
    pesoCaminoOptimo[0] = 0;
    
    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
        estaEnLaColaDePrioridad[v] = false;

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            if (estaEnLaColaDePrioridad[arco-&gt;vecino]) {
                float nuevoPeso = arco-&gt;peso;
                if (nuevoPeso &lt; pesoCaminoOptimo[arco-&gt;vecino]) {
                    pesoCaminoOptimo[arco-&gt;vecino] = nuevoPeso;
                    padre[arco-&gt;vecino] = v;
                    pq.cambiarPrioridad(arco-&gt;vecino, nuevoPeso);
                }
            }
        }
    }

    return padre;
}</code></pre><p id="60d32675-821d-47a3-89c3-61b59c59b0a4" class="">
</p><p id="0113974c-12ae-4f68-a599-987d5a3c1b54" class="block-color-blue">Destinos V√°lidos</p><pre id="c05ffab0-a8bc-4844-96ea-a5e0f2561947" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
vector&lt;bool&gt; GrafoDirigido::destinosValidos(int origen, int energia) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);
    vector&lt;bool&gt; resultado(vertices.size(), false);
    vector&lt;float&gt; caminoPesosOptimo(vertices.size(), INFINITO);

    caminoPesosOptimo[origen] = energia;
    resultado[origen] = true;

    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, caminoPesosOptimo[v]);    

    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
    
        for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente) {
            int energiaRestante = caminoPesosOptimo[v] - arco-&gt;peso;
            if (energiaRestante &gt;= 0){
                caminoPesosOptimo[arco-&gt;vecino] = energiaRestante;
                pq.cambiarPrioridad(arco-&gt;vecino, energiaRestante);
                resultado[arco-&gt;vecino] = true;
            }
        }
    }

    return resultado;
}</code></pre><p id="537b7548-129b-41fb-a601-522caf260802" class="">
</p><p id="da1aa22e-d871-416f-91a2-f5bb1db588bd" class="block-color-blue">Mostrar Ambulancias</p><pre id="4621f589-dd8a-4283-957f-5b1034134eca" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
void GrafoDirigido::mostrarAmbulancias(int destino,
                                       int ambulanciasNecesarias,
                                       const vector&lt;int&gt; &amp; ambulancias) const {

    vector&lt;int&gt; tiempoMinimo(vertices.size(), INFINITO);
    ColaDePrioridadDecrementable pq(vertices.size() - 1);
    
    tiempoMinimo[destino] = 0;

    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, tiempoMinimo[v]);    

    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
        
        if (tiempoMinimo[v] == INFINITO) {
            cout &lt;&lt; &quot;Si hay mas ambulancias no pueden llegar&quot; &lt;&lt; endl;
            return;
        }
        
        if (ambulancias[v] != -1) {
            cout &lt;&lt; &quot;Elegida ambulancia &quot; &lt;&lt; ambulancias[v];
            cout &lt;&lt; &quot; (tiempo de llegada estimado: &quot; &lt;&lt; tiempoMinimo[v] &lt;&lt; &quot;)&quot;&lt;&lt; endl; 
            if (--ambulanciasNecesarias == 0) {
                cout &lt;&lt; &quot;Conseguidas las ambulancias necesarias&quot; &lt;&lt; endl;
                return;
            }
        }

        for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente) {
            int vecino = arco-&gt;vecino;
            float nuevoTiempo = tiempoMinimo[v] + arco-&gt;peso;
            if (nuevoTiempo &lt; tiempoMinimo[vecino]) {
                tiempoMinimo[vecino] = nuevoTiempo;
                pq.cambiarPrioridad(vecino, nuevoTiempo);
            }
        }
    }
    cout &lt;&lt; &quot;No hay mas ambulancias&quot; &lt;&lt; endl;
}</code></pre><p id="e6ccbe8c-ecb9-40fa-ae6c-18b1f06c793d" class="">
</p><p id="e754001b-589b-414b-8d03-1ead2145b644" class="block-color-blue">Contar Caminos √ìptimos</p><pre id="9278e6c3-430c-4815-ae84-034c18dae97a" class="code"><code>#define INFINITO numeric_limits&lt;float&gt;::infinity()
int GrafoNoDirigido::contarCaminosOptimos(int origen, int destino) const {

    ColaDePrioridadDecrementable pq(vertices.size() - 1);

    vector&lt;float&gt; pesoCaminoOptimo(vertices.size(), INFINITO);
    vector&lt;int&gt; contadorCaminosOptimos(vertices.size(), 0);

    pesoCaminoOptimo[origen] = 0;
    contadorCaminosOptimos[origen] = 1;

    for (int v = 0; v &lt; vertices.size(); v++)
        pq.insertar(v, pesoCaminoOptimo[v]);
    
    while(!pq.estaVacia()) {
        int v = pq.eliminarMinimo();
        cout &lt;&lt; &quot; Elegido:  &quot; &lt;&lt; v &lt;&lt; endl;

        if (v == destino)
            return contadorCaminosOptimos[v];

        for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
            int vecino = arco-&gt;vecino;
            float nuevoPeso = pesoCaminoOptimo[v] + arco-&gt;peso;
            if (nuevoPeso &lt; pesoCaminoOptimo[vecino]) {
                pesoCaminoOptimo[vecino] = nuevoPeso;
                contadorCaminosOptimos[vecino] = contadorCaminosOptimos[v];
                pq.cambiarPrioridad(vecino, nuevoPeso);
            } else if (nuevoPeso == pesoCaminoOptimo[vecino])
                contadorCaminosOptimos[vecino] += contadorCaminosOptimos[v];
            cout &lt;&lt; &quot;   Vecino: &quot; &lt;&lt; vecino &lt;&lt; &quot;\t&quot; &lt;&lt; pesoCaminoOptimo[vecino];
            cout &lt;&lt; &quot;\t&quot; &lt;&lt; contadorCaminosOptimos[vecino] &lt;&lt; endl;
        }
    }

    return 0;
}</code></pre></details></li></ul><ul id="124e75a7-69a8-423a-aac7-53a6bad589c5" class="block-color-gray_background toggle"><li><details open=""><summary><strong>B√∫squeda en profundidad</strong></summary><p id="eedbfad4-d5e0-4ba6-a07c-e752d5ca2b05" class="">
</p><p id="21ccb6de-9246-47b2-86fc-2b36ba7baaeb" class="block-color-blue">Contar Picaduras</p><pre id="252984d5-17e1-41e4-b8a9-b4ae6b9d191c" class="code"><code>int GrafoNoDirigido::contarPicaduras() const {
    
    vector&lt;bool&gt; contagio(vertices.size(), false);
    int picaduras = 0;

    for (int v = 0; v &lt; vertices.size(); v++)
        if (!contagio[v]) {
            picaduras++;
            contarPicaduras(contagio, v);
        }

    return picaduras; 
}

void GrafoNoDirigido::contarPicaduras(vector&lt;bool&gt; &amp; contagio,
                                     int v) const {

    contagio[v] = true;

    for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente)
        if (!contagio[arco-&gt;vecino])
            contarPicaduras(contagio, arco-&gt;vecino);
}</code></pre><p id="32b5db16-b940-4940-ba1e-e688a5f3de6a" class="block-color-blue">Es Alcanzable</p><pre id="e4e239ce-3a7c-4686-8f2d-14cbd2d8cea5" class="code"><code>bool GrafoDirigido::esAlcanzable(vector&lt;bool&gt; &amp; visitado, int destino, int v) const{
    
    if (v == destino)
        return true;
    
    visitado[v] = true;

    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
        if (!visitado[arco-&gt;vecino])
            if (esAlcanzable(visitado, destino, arco-&gt;vecino))
                return true;
    return false;
}

bool GrafoDirigido::esAlcanzable(int origen, int destino) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);

    return esAlcanzable(visitado, destino, origen);    
}</code></pre><p id="aae4c540-2e87-4a2a-b7ee-c89c1244e42a" class="">
</p><blockquote id="57c2be38-af59-43d0-a6b3-23092f617e9a" class="block-color-gray"><em>La soluci√≥n eficiente de este ejercicio pasa por iniciar el recorrido en el v√©rtice donde est√° el queso y recorrer el grafo a trav√©s de sus v√©rtices de entrada hasta alcanzar o no a todos los ratones</em></blockquote><p id="f4dd8a3b-95a5-4f44-a936-4aa198549a69" class="block-color-blue">Queso Alcanzable por todos los ratones</p><pre id="8cca769f-5247-4cf4-83c0-5d4d70d7eae7" class="code"><code>// Version recursiva
bool GrafoDirigido::buscarRatones(int v,
                                  const vector&lt;bool&gt; &amp; raton,
                                  int &amp; cantidadDeRatonesPorVisitar,
                                  vector&lt;bool&gt; &amp; visitado) const {
    if (raton[v] &amp;&amp; --cantidadDeRatonesPorVisitar == 0)
        return true;

    visitado[v] = true;
    
    for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
        if(!visitado[arco-&gt;vecino])
            if (buscarRatones(arco-&gt;vecino, raton, cantidadDeRatonesPorVisitar, visitado))
                return true;

    return false;
}

bool GrafoDirigido::quesoAlcanzablePorTodosLosRatones(int queso, const vector&lt;bool&gt; &amp; raton) const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    int cantidadDeRatonesPorVisitar = 0;

    for (int v = 0; v &lt; vertices.size(); v++)
        if (raton[v])    
            cantidadDeRatonesPorVisitar++;

    if (cantidadDeRatonesPorVisitar == 0)
        throw string (&quot;Faltan los ratones&quot;);

    return buscarRatones(queso, raton, cantidadDeRatonesPorVisitar, visitado);    
}

// Version Iterativa
bool GrafoDirigido::quesoAlcanzablePorTodosLosRatones(int queso, 
                                    const vector&lt;bool&gt; &amp; raton) const {
    int cantidadDeVertices = vertices.size();

    vector&lt;bool&gt; visitado(cantidadDeVertices, false);
    queue&lt;int&gt; cola;

    int cantidadDeRatonesPorVisitar = 0;

    for (int v = 0; v &lt; cantidadDeVertices; v++)
        if (raton[v])
            cantidadDeRatonesPorVisitar++;
    
    if (cantidadDeRatonesPorVisitar == 0)
        throw string (&quot;Faltan los ratones&quot;);
    
    if (raton[queso] &amp;&amp; --cantidadDeRatonesPorVisitar == 0)
        return true;
    
    visitado[queso] = true;
    cola.push(queso);

    while(!cola.empty()) {
        int v = cola.front();
        cola.pop();
        for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
            if (!visitado[arco-&gt;vecino]) {
                if (raton[arco-&gt;vecino] &amp;&amp; --cantidadDeRatonesPorVisitar == 0)
                    return true;
                visitado[arco-&gt;vecino] = true;
                cola.push(arco-&gt;vecino);
            }
    }
    
    return true;
}</code></pre><p id="501867fc-60da-409f-a327-a17d3d6b48f3" class="">
</p><p id="48d08c91-11e2-48b1-b7d6-78eea91ea1d9" class="block-color-blue"><a href="https://en.wikipedia.org/wiki/Kosaraju&#x27;s_algorithm">Traza Kosaraju-Sharir</a> para averiguar componentes <a href="https://es.wikipedia.org/wiki/Componente_fuertemente_conexo">Fuertemente Conexas</a></p><p id="767391cb-c9fa-4376-acc3-97fbf8034ddd" class="">
</p><blockquote id="1f473cc9-a237-44fc-9419-6ab8755005a0" class="block-color-gray"><em>Hacemos uso del algoritmo de Kosaraju-Sharir para averiguar componentes Fuertemente Conexas</em></blockquote><p id="e437598c-93a8-4060-bf7e-7e54b8426731" class="block-color-blue">Colorear Conectados</p><pre id="46302628-d3a1-4270-840d-a1b0e4ebf46f" class="code"><code>#define SIN_COLOR -1
void GrafoDirigido::KosarajuSharirEtapa2DFS(int v, 
                                            vector&lt;int&gt; &amp; colores, 
                                            int color) const {
    colores[v] = color;
    for (Arco * arco = vertices[v].primerArcoDeEntrada; arco != nullptr; arco = arco-&gt;siguiente)
        if (colores[arco-&gt;vecino] == SIN_COLOR)
            KosarajuSharirEtapa2DFS(arco-&gt;vecino, colores, color);
}

void GrafoDirigido::KosarajuSharirEtapa1DFS(int v, 
                                            vector&lt;bool&gt; &amp; visitado,
                                            stack&lt;int&gt; &amp; pila) const {
    visitado[v] = true;
    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
        if (!visitado[arco-&gt;vecino])
            KosarajuSharirEtapa1DFS(arco-&gt;vecino, visitado, pila);    
    pila.push(v);
}

vector&lt;int&gt; GrafoDirigido::colorearConectados() const {
    
    vector&lt;bool&gt; visitado(vertices.size(), false);
    vector&lt;int&gt; colores(vertices.size(), SIN_COLOR);
    stack&lt;int&gt; pila;
    int color = 0, origen;

    for (origen = 0; origen &lt; vertices.size(); origen++) {
        if (!visitado[origen])
            KosarajuSharirEtapa1DFS(origen, visitado, pila);
    }
    
    while (!pila.empty()) {
        int origen = pila.top();
        pila.pop();
        if (colores[origen] == SIN_COLOR)
            KosarajuSharirEtapa2DFS(origen, colores, ++color);
    }    

    return colores;
}</code></pre><p id="ed383cf9-f485-429e-a638-b3b3d4485408" class="block-color-blue">
</p><p id="1d762bec-3b91-4f27-810a-3909cef369c8" class="block-color-blue">Repartir Islas</p><pre id="825aacc5-6b73-4ac5-860c-9b22a1bdceb4" class="code"><code>#define SIN_EQUIPO -1
void GrafoNoDirigido::repartirIslasBFS(int v, 
                                       int e,
                                       vector&lt;int&gt; &amp; equipo) const {
    e = e == 1 ? 2 : 1;
    equipo[v] = e;

    for (Arco * arco = vertices[v].primerArco; arco != nullptr; arco = arco-&gt;siguiente) {
        if (equipo[arco-&gt;vecino] == SIN_EQUIPO) {
            repartirIslasBFS(arco-&gt;vecino, e, equipo);
        } else if (equipo[v] == equipo[arco-&gt;vecino])
            throw string(&quot;No existe solucion: el grafo no es bipartido&quot;);
    }
}

// Repartir islas para que cada una pertenezca a un equipo y solo a uno
// No haya dos islas conectadas por un puente asignadas la mismo equipo
vector&lt;int&gt; GrafoNoDirigido::repartirIslas() const {
    
    vector&lt;int&gt; equipo(vertices.size(), SIN_EQUIPO);

    for (int v = 0; v &lt; vertices.size(); v++)
        if (equipo[v] == SIN_EQUIPO)
            repartirIslasBFS(v, 2, equipo);    

    return equipo;
}</code></pre><p id="deaa6585-d0ec-4a89-9560-8e1d8102659b" class="block-color-blue">
</p><p id="13578c68-70ab-4c4f-b3f1-741c6b5a3bb8" class="block-color-blue">Orden Topol√≥gico</p><pre id="7fbc2dd6-fc69-4561-a5ee-39cfee5243f7" class="code"><code>void GrafoDirigido::obtenerOrdenTopologicoDFS(int v, 
                                              vector&lt;bool&gt; &amp; visitado, 
                                              stack&lt;int&gt; &amp; pila) const {
    visitado[v] = true;
    
    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente)
        if (!visitado[arco-&gt;vecino])
            obtenerOrdenTopologicoDFS(arco-&gt;vecino, visitado, pila);

    pila.push(v);
}

void GrafoDirigido::mostrarOrdenTopologico() const {

    vector&lt;bool&gt; visitado(vertices.size(), false);
    stack&lt;int&gt; pila;

    for (int v = 0; v &lt; vertices.size(); v++)
        if (vertices[v].gradoDeEntrada == 0)    
            obtenerOrdenTopologicoDFS(v, visitado, pila);


    while (!pila.empty()) {
        int v = pila.top();
        pila.pop();
        cout &lt;&lt; &quot;  --&gt; &quot; &lt;&lt;  v &lt;&lt; endl;
    }
}</code></pre><p id="8e7b349c-3df8-4e62-9d48-32358d6f731c" class="block-color-blue">
</p><p id="ed898453-7e01-4246-9214-e921a89af4b2" class="block-color-blue">Aciclicidad</p><pre id="4e7c391e-2a77-4695-9686-6db7ad0350f7" class="code"><code>bool GrafoDirigido::buscarCicloDFS(int v, 
                                   vector&lt;int&gt; &amp; estado) const {

    estado[v] = 1;

    for (Arco * arco = vertices[v].primerArcoDeSalida; arco != nullptr; arco = arco-&gt;siguiente) {
        if (estado[arco-&gt;vecino] == 1)
            return true;
        if (estado[arco-&gt;vecino] == 0)
            if (buscarCicloDFS(arco-&gt;vecino, estado))
                return true;
    }
    
    estado[v] = 2;
    
    return false;
}


bool GrafoDirigido::esAciclico() const {
    // Estado 0: No visitado
    // Estado 1: Ha iniciado la busqueda pero no ha terminado
    // Estado 2: Ha sido visitado
    vector&lt;int&gt; estado(vertices.size(), 0);
    
    for (int v = 0; v &lt; vertices.size(); v++)
        if (estado[v] == 0)
            if (buscarCicloDFS(v, estado))
                return false;

    return true;
}</code></pre></details></li></ul><p id="80419861-0202-42a4-9cfa-a57a179547f2" class="">
</p></div></article></body></html>