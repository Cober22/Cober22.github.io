<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Algoritmos Resumen General</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1b9f3017-20ec-4d63-96d6-99fd95d9bcbd" class="page sans"><header><img class="page-cover-image" src="https://c.tenor.com/r9gRUQerG48AAAAd/vladimir-putin-putin.gif" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📚</span></div><h1 class="page-title">Algoritmos Resumen General</h1></header><div class="page-body"><p id="3719cac8-1f83-4585-b44b-8ab93c50729e" class="">
</p><h3 id="5a31728d-785f-4549-87c2-c57a9e3260c7" class="block-color-blue_background"> TEMA 1</h3><ul id="ecef1d7c-3280-4363-b99a-4f53b3d8cd83" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Costes</strong></summary><blockquote id="d41c5875-9456-4fa5-bbe3-87c816ea11ec" class="block-color-gray"><em>Costes Cola de Prioridad</em></blockquote><table id="a50289dd-d68d-4d2a-bc8e-87e39a207026" class="simple-table"><tbody><tr id="08ee5dc4-58aa-4b49-809a-b6768462ba23"><td id="OEoe">Cola de Prioridad</td><td id="Kh[\">Insertar</td><td id="tvLx">Eliminar Mínmo</td><td id="n:Tw">Consultar Mínimo</td></tr><tr id="194409d4-37ac-4a47-a1e6-335bc10a14cf"><td id="OEoe">vector no ordenado</td><td id="Kh[\">O(1)</td><td id="tvLx">O(n)</td><td id="n:Tw">O(1)</td></tr><tr id="e820ef15-44ba-49ac-b233-b7a3a7efb22e"><td id="OEoe">vector ordenado</td><td id="Kh[\">O(n)</td><td id="tvLx">O(1)</td><td id="n:Tw">O(1)</td></tr><tr id="b7ccbc62-3330-4f3e-9675-77fa20cae9bd"><td id="OEoe">lista enlazada no ordenada</td><td id="Kh[\">O(1)</td><td id="tvLx">O(n)</td><td id="n:Tw">O(1)</td></tr><tr id="61d3c086-65bd-4068-8b74-7da40679c2c5"><td id="OEoe">lista enlazada ordenada</td><td id="Kh[\">O(n)</td><td id="tvLx">O(1)</td><td id="n:Tw">O(1)</td></tr></tbody></table><blockquote id="1fce67ca-ab36-4c58-ae28-c9ebbf23d397" class="block-color-gray"><em>Costes Conjunto y Multi-Conjunto</em></blockquote><table id="0b5fae74-4813-4ce2-89df-ba5d5cc9fc6a" class="simple-table"><tbody><tr id="77353547-2bdd-4afd-8fb9-175ffb8e41b4"><td id="`Ou^">Conjunto</td><td id="|FZf">Insertar</td><td id="c^qv">Eliminar</td><td id="KcTd">Buscar</td></tr><tr id="8d89f536-6ba8-4782-91a8-8187979988c0"><td id="`Ou^">vector no ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(1)</td></tr><tr id="b8b2cb81-b4be-45d0-b243-577d623a6090"><td id="`Ou^">vector ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(log n)</td></tr><tr id="f1fee4a7-f1d3-40b9-848a-7000484d67d8"><td id="`Ou^">lista enlazada no ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr><tr id="b88ce96f-e857-48d5-a3e5-b3695816b61e"><td id="`Ou^">lista enlazada ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr></tbody></table><table id="7dad3cb1-376e-434a-bcfa-47c623c2b947" class="simple-table"><tbody><tr id="badc2e70-3601-4aeb-85a4-a0d4b05f1fd3"><td id="`Ou^">Multi-Conjunto</td><td id="|FZf">Insertar</td><td id="c^qv">Eliminar</td><td id="KcTd">Buscar</td></tr><tr id="16832cf5-a7e8-4496-8f10-be5bb9b3cced"><td id="`Ou^">vector no ordenado</td><td id="|FZf">O(1)</td><td id="c^qv">O(n)</td><td id="KcTd">O(1)</td></tr><tr id="a2909c40-37ee-4ce6-a0d1-35ee1191dfd9"><td id="`Ou^">vector ordenado</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(log n)</td></tr><tr id="fb0f0cd2-c539-4960-942a-5d9aabfaebdb"><td id="`Ou^">lista enlazada no ordenada</td><td id="|FZf">O(1)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr><tr id="157d3192-5c67-4878-b5d4-29e50133b52d"><td id="`Ou^">lista enlazada ordenada</td><td id="|FZf">O(n)</td><td id="c^qv">O(n)</td><td id="KcTd">O(n)</td></tr></tbody></table><p id="a5a7fca9-193f-4b06-8201-724a4c815d84" class="">
</p><blockquote id="db3fee31-ccd9-45d6-ae6c-cd3cada03703" class="block-color-gray"><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA5.1/solucion_coste_temporal_Huffman.html"><em>Huffman implementado en varias estructuras de datos</em></a></blockquote><table id="8aab093f-1cc6-425d-8930-5e51e78612c2" class="simple-table"><tbody><tr id="8d9a7324-b869-4aa8-910c-f30c46ff8226"><td id="?ecC"></td><td id="W{[\">Inserción de N datos</td><td id="E[TW">Dos operaciones de eliminar mínimo N veces</td><td id="`_Nk">Una operación de inserción N veces</td></tr><tr id="49bbba3a-44f1-4642-a489-d1e71af1b5b6"><td id="?ecC">Vector no ordenado</td><td id="W{[\">O (n)</td><td id="E[TW">O (n)</td><td id="`_Nk">O (n^2)</td></tr><tr id="845c1216-a4b1-4884-bc7d-d38c35581f34"><td id="?ecC">Vector ordenado</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n)</td><td id="`_Nk">O (n^2)</td></tr><tr id="f8756f1c-1be4-4faf-8ca7-41abd05dda5d"><td id="?ecC">Árbol binario de búsqueda</td><td id="W{[\">O (n^2) </td><td id="E[TW">O (n^2)</td><td id="`_Nk">O (n^2)</td></tr><tr id="34199eb7-6594-404f-97c3-66c2f4cf2ef8"><td id="?ecC">Árbol de AVL</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr><tr id="4618a21b-1aca-46ea-8bdc-b79e8d7950fb"><td id="?ecC">Montículo binario</td><td id="W{[\">O (n log n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr><tr id="07841dcb-a558-4031-90f1-202535e13b40"><td id="?ecC">Montículo de Fibonacci</td><td id="W{[\">O (n)</td><td id="E[TW">O (n log n)</td><td id="`_Nk">O (n log n)</td></tr></tbody></table></details></li></ul><h3 id="17ac309e-ffab-4e05-9b8c-fa66790d7a14" class="block-color-blue_background"> TEMA 2</h3><ul id="866fb524-f16d-4de6-8355-4f484f8f4f47" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Colas de Prioridad</strong></summary><blockquote id="96dd3169-cae3-4673-a8e4-ab962790421e" class="block-color-gray"><em>Estudia la implementación de la clase Cola y la clase Pila. Es importante entender lo que se ha hecho para conseguir los costes O(1) y en que se diferencia. Añade a la implementación de cola estos métodos:</em></blockquote><p id="6a17f066-2c1d-4917-9208-e18c58ddaaa7" class="block-color-blue">Buscar</p><pre id="4df96f44-69f8-493c-a439-07e9205f4b05" class="code"><code>// Buscar iterativo
bool Cola::buscar(int n) const {
    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente)
        if(actual-&gt;dato == n)
            return true;
    
    return false;
}

// Buscar recursivo
bool Cola::buscarRecursivo(int n, Nodo * actual) const {
    if (actual == nullptr)
        return false;

    if (actual-&gt;dato == n)
        return true;
    
    return buscarRecursivo(n, actual-&gt;siguiente);
}

bool Cola::buscarRecursivo(int n) const {
    buscarRecursivo(n, primero);
}</code></pre><p id="a3b3b418-b587-403d-9298-1bde00b0910f" class="block-color-blue">Buscar Posicion</p><pre id="fdfbd5d3-78f6-4f73-93e7-cf65581c3a4f" class="code"><code>// BuscarPosicion Iterativo
int Cola::buscarPosicion(int n) const {
    int posicion = 0;

    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente, posicion++)
        if(actual-&gt;dato == n)
            return posicion;

    return -1; 
}

//Buscar posiciones Recursivo
int Cola::buscarPosicionRecursivo(int n, Nodo * actual, int posicion) const{
    
    if(actual == nullptr)
        return -1;
    if(actual-&gt;dato == n)
        return posicion;
        
    return buscarPosicionRecursivo(n, actual-&gt;siguiente, posicion + 1);;
}

int Cola::buscarPosicionRecursivo(int n) const {   
    buscarPosicionRecursivo(n, primero, 0);
}</code></pre><p id="6d55fe4d-ec3f-471a-baa0-78591661418a" class="block-color-blue">Colas Iguales</p><pre id="72d5f033-08a5-4bc4-9f7c-1115eec170e7" class="code"><code>// ColasIguales Iterativo
bool Cola::colasIguales(const Cola &amp; cola) const {
    
    Nodo * actual = primero;
    Nodo * actualCola = cola.primero;

    while (actual != nullptr &amp;&amp; actualCola != nullptr) {
        if(actual-&gt;dato != actualCola-&gt;dato)
            return false;
        actual = actual-&gt;siguiente;
        actualCola = actualCola-&gt;siguiente;
    }

    return actual == nullptr &amp;&amp; actualCola == nullptr;
}

// ColasIguales Recursivo
bool Cola::colasIgualesRecursivo(Nodo * actual, Nodo * actualCola) const {

    if (actual == nullptr &amp;&amp; actualCola == nullptr)
        return true;
    
    if (actual == nullptr || actualCola == nullptr)
        return false;

    return actual-&gt;dato == actualCola-&gt;dato 
				&amp;&amp; colasIgualesRecursivo(actual-&gt;siguiente, actualCola-&gt;siguiente);
}

bool Cola::colasIgualesRecursivo(const Cola &amp; cola) const {
    colasIgualesRecursivo(primero, cola.primero);
}</code></pre><p id="15baa6d0-92e1-49bc-806d-a67f45b3acf7" class="block-color-blue">Eliminar</p><pre id="3b206303-611a-47fd-b85e-59391204bd6d" class="code"><code>// Eliminar Iterativo
void Cola::eliminar(int n) {
    if (primero == nullptr)
        throw string(&quot;Intentando eliminar un elemento de una cola vacía&quot;);
    
    Nodo * anterior = primero;
    for (Nodo * actual = primero; actual != nullptr; actual = actual-&gt;siguiente) {
        if (actual-&gt;dato == n) {
            if (actual == ultimo)
                ultimo = anterior;
            if (actual == primero)
                primero = primero-&gt;siguiente;
            else
                anterior-&gt;siguiente = actual-&gt;siguiente;
            delete actual;
        }
        anterior = actual;
    }    
}

// Eliminar Recursivo
void Cola::eliminarRecursivo(int n, Nodo * &amp; actual, Nodo * anterior) {
    if (actual == nullptr)
        return;
    
    if(actual-&gt;dato == n) {
        Nodo * basura = actual;
        anterior-&gt;siguiente = actual-&gt;siguiente;
        delete basura;
        if (actual == nullptr)
            ultimo = anterior;
    }
    else 
        eliminarRecursivo(n, actual-&gt;siguiente, anterior);
}

void Cola::eliminarRecursivo(int n) {
    eliminarRecursivo(n, primero, primero);
}</code></pre></details></li></ul><ul id="23f7bf7b-2430-4a95-a5af-08f8f71d6eb1" class="block-color-gray_background toggle"><li><details open=""><summary><strong>Lista doblemente enlazada</strong></summary><blockquote id="8ec68d42-3c8f-4301-afca-fc75397c3398" class="block-color-gray"><em>Una cola de prioridad de doble fin permite: insertar un elemento que tiene una cierta prioridad, extraer un elemento de minima prioridad y extraer un elemento de máxima prioridad. A estos hay que añadirles ciertos métodos que deben funcionar en los tiempos indicados:</em></blockquote><p id="a0bd76b3-7f94-4c29-af49-1062d54ca783" class="block-color-blue">Insertar</p><pre id="48bb595c-1935-464e-90b3-c496dd6cd46c" class="code"><code>// Insertar
void ColaDePrioridadDeDobleFin::insertar(int prioridad) {
    
    laTalla++;
    if (minimo == nullptr)
        minimo = maximo = new Nodo(prioridad, nullptr, nullptr);
    else if(prioridad &lt;= minimo-&gt;prioridad) {
        minimo = new Nodo(prioridad, nullptr, minimo);
        minimo-&gt;anterior-&gt;siguiente = minimo;
    } else if(prioridad &gt;= maximo-&gt;prioridad) {
        maximo = new Nodo(prioridad, maximo, nullptr);
        maximo-&gt;siguiente-&gt;anterior = nuevo;
    } else  {
        for(Nodo * actual = minimo; actual != nullptr, actual = actual -&gt;siguiente) {
            if(actual-&gt;dato == d) {
                Nodo * nuevo = new Nodo(prioridad, actual-&gt;anterior, actual)
                actual-&gt;anterior-&gt;siguiente = nuevo;
                actual-&gt;anterior = nuevo; 
                return;
            }
        }
    }
}</code></pre><p id="72775b1b-6d26-42a2-973a-a7411cb95359" class="block-color-blue">Eliminar</p><pre id="303dbc50-7610-4f44-8293-05d782310f45" class="code"><code>// Eliminar
void ColaDePrioridadDeDobleFin::eliminar(int prioridad) {
    for(Nodo * actual = minimo; actual != nullptr, actual = actual -&gt;siguiente) { 
        if (actual-&gt;prioridad == prioridad) {
            if(minimo == maximo)
                minimo = maximo = nullpter
            else if(prioridad == minimo-&gt;prioridad) {
                minimo = minimo-&gt;siguiente;
                minimo-&gt;anterior = nullptr;
            } else if (prioridad == maximo-&gt;prioridad) {
                maximo = maximo-&gt;anterior;
                minimo-&gt;siguiente = nullptr;
            } else {
                actual-&gt;anterior-&gt;siguiente = actual-&gt;siguiente;
                actual-&gt;siguiente-&gt;anterior = actual-&gt;anterior;
            }
            delete actual;
            laTalla--;
            return;
        }
    }
}</code></pre><p id="feac6119-6684-4e55-8828-58e25f6e6c84" class="block-color-blue">Vaciar</p><pre id="bc1878cf-61fa-457b-8245-21d7ddee6452" class="code"><code>// Vaciar
void ColaDePrioridadDeDobleFin::vaciar() const {
    Nodo * basura;
    while(minimo != nullptr) {
        basura = minimo;
        minimo = minimo-&gt;siguiente;
        delete basura;
    } 

    minimo = maximo = nullptr;
    laTalla = 0;
}</code></pre><p id="6a468f55-e2e8-4d84-9530-07af996e9e42" class="block-color-blue">Unir →O(a + b)</p><pre id="24634afa-5d4f-48a7-a496-6e9bcca227b0" class="code"><code>// Unir
void ColaDePrioridadDeDobleFin::unir(const ColaDeProiridadDeDobleFin &amp; cola1, const ColaDeProiridadDeDobleFin &amp; cola2) {
    Nodo * actualCola1 = cola1-&gt;primero;
    Nodo * actualCola2 = cola2-&gt;segundo;
    vaciar();
    laTalla = 0;

    while (actualCola1 != nullptr &amp;&amp; actualCola2 != nullptr) {
        if (actualCola1-&gt;priodidad &lt;= actualCola2-&gt;prioridad) {
            insertar(actualCola1-&gt;prioridad);
            actualCola1 = actualCola1-&gt;siguiente;
        }
        else {
            insertar(actualCola1-&gt;prioridad);
            actualCola2 = actualCola2-&gt;siguiente;
        }
        laTalla++;
    }

    while (actualCola1 != nullptr) {
        insertar(actualCola1-&gt;prioridad);
        actualCola1 = actualCola1-&gt;siguiente;
        laTalla++;
    }

    while (actualCola2 != nullptr) {
        insertar(actualCola2-&gt;prioridad);
        actualCola2 = actualCola2-&gt;siguiente;
        laTalla++;
    }
}</code></pre><p id="1e3756fe-4433-41a5-8f43-d500fc623ba8" class="">
</p></details></li></ul><h3 id="e944bf87-ab68-4e03-87a7-0498a3dfb600" class="block-color-blue_background"> TEMA 3</h3><ul id="75a658db-3624-43be-a317-9faec812cc92" class="block-color-gray_background toggle"><li><details open=""><summary>Árbol binario de búsqueda</summary><blockquote id="2ff16b97-5adc-4b83-8513-2ca2e5b948dd" class="">Partiendo de la versión inicial de la implementación del TAG Conjunto:</blockquote><p id="fa3e15ae-cb91-4fd1-8d00-9f9ea6ca5399" class="">Sumar</p><pre id="be22a81e-395a-417e-8885-9ea6f703d7d1" class="code"><code></code></pre><p id="29729005-9179-430d-b2da-347915d65ec5" class="">
</p><p id="6e4b802b-e6e2-4eea-b0bf-3d61fa8ffb80" class="">Incrementar Todos</p><pre id="ac93d57e-7f1a-41da-aec1-38d35743679a" class="code"><code></code></pre><p id="ad94c192-837a-46d3-b4fd-80db1ae8a187" class="">
</p><p id="38241b31-45de-4b88-a070-9381d5a85099" class="">Mostrar Ordenados</p><pre id="a61cbcde-216e-48ba-80d8-b6bb3c783842" class="code"><code>2void Conjunto::mostrarOrdenados(Nodo * actual) const {
    if (actual != nullptr) {
        mostrarOrdenados(actual-&gt;izquierdo);
        cout &lt;&lt; actual-&gt;dato &lt;&lt; &quot; &lt; &quot;;
        mostrarOrdenados(actual-&gt;derecho);
    }
}

void Conjunto::mostrarOrdenados() const {
    cout &lt;&lt; &quot;[&quot;;
    mostrarOrdenados(raiz);
    cout &lt;&lt; &quot;]&quot;;
}</code></pre><p id="813d5a58-37d2-41fd-8502-b09ffa402929" class="">
</p><p id="80e90ca5-debe-4b49-8ce0-59d5a5e669db" class="">Obtener Ordenados</p><pre id="dced472e-068f-49cb-9e45-891da8b7ea15" class="code"><code>void Conjunto::obtenerOrdenados(vector&lt;int&gt; vectorOrdenados, Nodo * actual, int i) const {
    if (actual != nullptr) {
        obtenerOrdenados(vectorOrdenados, actual-&gt;izquierdo, i);
        vectorOrdenados[i++] = actual-&gt;dato;
        obtenerOrdenados(vectorOrdenados, actual-&gt;derecho, i);
    }
}

vector&lt;int&gt; Conjunto::obtenerOrdenados() const {
    vector&lt;int&gt; vectorOrdenados(laTalla);
    int i = 0;
    obtenerOrdenados(vectorOrdenados, raiz, i);
    return vectorOrdenados;
}</code></pre><p id="926957d6-a45b-4feb-b198-0f1f6b731cb9" class="">
</p><p id="08a0a7e1-8f28-4290-9f60-c333240c0455" class="">Buscar</p><pre id="d2de33f0-8783-463f-ac0e-e056822c427b" class="code"><code>bool Conjunto::buscar(int dato, Nodo * actual) const {
    if (actual == nullptr)
        return false;
    if(actual-&gt;dato &gt; dato)
        buscar(dato, actual-&gt;izquierdo);
    if(actual-&gt;dato &lt; dato)
        buscar(dato, actual-&gt;derecho);

    return false;
}

bool Conjunto::buscar(int dato) const {
    return buscar(dato, raiz);
}</code></pre><p id="8c4b3fcb-ee78-4959-b030-477de3d1b7f5" class="">
</p><p id="59d2d24d-cc4c-44fb-838b-f6eb91c2029a" class="">Insertar</p><pre id="f25276a9-055e-4aaa-bf53-0e22c3c99df3" class="code"><code>void Conjunto::insertar(int dato) {
    Nodo * actual = raiz;
    while (actual != nullptr) {
        if(dato == actual-&gt;dato) // No insertamos duplicados
            return; 
        else if(dato &lt; actual-&gt;dato)
            actual = actual-&gt;izquierdo;
        else
            actual = actual-&gt;derecho;
            
    }
    actual = new Nodo(dato);
    laTalla++;
}</code></pre><p id="4fb61196-5c7a-4dc6-9a24-5f066e1778f9" class="">
</p><p id="91e8f8f2-64e9-4414-b6d4-d4651cb1487b" class="">Vaciar</p><pre id="fcbce1ed-5b59-46dd-a60e-8d620434a293" class="code"><code>void Conjunto::vaciar(Nodo * actual) {
    if(actual != nullptr) {
        vaciar(actual-&gt;izquierdo);
        vaciar(actual-&gt;derecho);
        delete actual;
    }
}

void Conjunto::vaciar() {
    vaciar(raiz);
    laTalla = 0;
    raiz = nullptr;
}</code></pre><p id="148ac595-7523-4c27-88fb-53190a26fccc" class="">
</p><p id="19499116-9725-4f22-8559-3af84b711ce0" class="">Es Árbol Binario de Búsqueda</p><pre id="e498a118-2e54-48ff-b284-4ebee1f88805" class="code"><code>bool Conjunto::esArbolBinarioDeBusqueda() const {
    vector&lt;int&gt; vectorArbol(laTalla);
    int i = 0;
    obtenerOrdenados(vectorArbol, raiz, i);

    for (i = 1; i &lt; laTalla; i++)
        if (vectorArbol[i - 1] &gt; vectorArbol[i])
            return false;\
    return true;        
}</code></pre></details></li></ul><ul id="0c1986eb-ba8e-49e1-97da-99fa8a9b059f" class="block-color-gray_background toggle"><li><details open=""><summary>AVL</summary></details></li></ul><ul id="0bf42290-3086-4f5a-8aa1-8dd4d505f19b" class="block-color-gray_background toggle"><li><details open=""><summary>Diccionarios</summary><blockquote id="565c9fba-a81e-4211-b725-e8cbebfadfdd" class=""> Esta implementación del TAD Diccionario permite almacenar datos de tipo entero con claves de tipo cadena, empleando internamente un árbol binario de búsqueda</blockquote><p id="ebf9fa13-afbd-45a1-b826-9f0f3c061464" class="">Insertar</p><pre id="9d8819cd-f956-435a-acd9-6043c9830fe5" class="code"><code></code></pre><p id="0244311c-6a3a-45ab-95a2-8731958a407a" class="">
</p><p id="68669070-6415-4ea3-a372-8ea45dcc029d" class="">Eliminar</p><pre id="592e6bff-9f76-4b07-a167-d1cf6e0be087" class="code"><code></code></pre><p id="9b9ee6b6-8db8-4a6a-8900-792a85afe29c" class="">
</p><p id="c48718d0-57b9-44cd-96f7-e0d58fb55c15" class="">Buscar</p><pre id="c271099c-e06f-4d49-a5af-ec1ad5db3050" class="code"><code></code></pre></details></li></ul><ul id="7d004dcb-5ddc-47d2-b0dd-70e8ff45fea7" class="block-color-gray_background toggle"><li><details open=""><summary>Métodos árboles</summary><p id="de4f8f4b-d482-4606-900b-b1102b77d9a3" class="">Altura Arbol</p><pre id="e81b8c5c-9ae5-4202-8f81-eff301a7dcb5" class="code"><code></code></pre><p id="4ed6f76a-d20f-45fb-873f-51cda65a80f0" class="">No Hay Hijo Sin Hermano</p><pre id="d1e174c0-b56f-42cd-a5b7-f0538403939b" class="code"><code></code></pre><p id="c36da7b4-dd1e-4946-847c-c604cc724173" class="">
</p><p id="570411f2-240a-444d-b0f7-e87da51c5411" class="">Arboles Iguales</p><pre id="6bf1e62c-218b-4859-8935-c4f8bdbac83e" class="code"><code></code></pre><p id="d3b05f90-f5e0-4d0b-a34a-112325f019b2" class="">
</p><p id="da2ba3bd-8d84-4adb-8b14-57252520b202" class="">Mostrar Por Nivel</p><pre id="dd07cf30-303c-4ec5-833a-13728abfcb76" class="code"><code></code></pre><p id="d44b51ed-9a03-4fb6-8329-3da7d6a165fb" class="">
</p><p id="08aa2019-dce6-4fa0-8fc3-079d1428d675" class="">Verificar Profundidad</p><pre id="d77b00ab-6210-4d62-bdf7-98bd396b15d6" class="code"><code></code></pre></details></li></ul><h3 id="742247c6-f0f6-4329-935f-648cb7e914da" class="block-color-blue_background"> TEMA 4</h3><ul id="fb90062e-f29e-4d7f-ac6a-2380226d7380" class="block-color-gray_background toggle"><li><details open=""><summary>Huffman</summary><blockquote id="21097456-80bb-4f46-97c3-0292d0bb7245" class="block-color-gray"><em>Implementar el constructor de la clase Huffman y métodos para codificar y decodificar. </em><strong><a href="https://es.wikipedia.org/wiki/Algoritmo_de_Huffman#Descripci.C3.B3n"><em>Explicación</em></a></strong></blockquote><blockquote id="3beab4b6-b00d-40d6-ba34-e48193d69f44" class="block-color-gray"><em>Los costes en el algoritmo de Huffman van a depender de la estructura interna con que decidamos implementarlo: vector ordenado, AVL, montículo binario...</em></blockquote><p id="7028473e-12f6-489f-9eb1-f98bdc9023e3" class="block-color-blue">Constructor</p><pre id="448e22d9-1e0a-48b4-b9b8-1ba71269c2ea" class="code"><code>Huffman::Huffman(const vector&lt;pair&lt;char, float&gt;&gt; &amp; frecuencias) : raiz{nullptr} {

    if (frecuencias.size() &lt; 2)
        throw string(&quot;Necesitamos al menos dos caracteres con sus frecuencias&quot;);

    class ComparadorNodos {
    public:
        bool operator() (Nodo* nodo1, Nodo* nodo2) const {
            return nodo1-&gt;frecuencia &gt; nodo2-&gt;frecuencia;
        }
    };

    priority_queue&lt;Nodo *, vector&lt;Nodo *&gt;, ComparadorNodos&gt; colaDePrioridad;

    for (const auto caracter : frecuencias) {
        Nodo * nuevo = new Nodo(caracter.first, caracter.second);
        colaDePrioridad.push(nuevo);
        hojas.emplace(caracter.first, nuevo);
    }

    while(colaDePrioridad.size() &gt; 1) {        
        Nodo* n = new Nodo(&#x27; &#x27;, 0);
        n-&gt;izquierdo = colaDePrioridad.top();
        colaDePrioridad.pop();
        n-&gt;derecho = colaDePrioridad.top();
        colaDePrioridad.pop();

        n-&gt;frecuencia = n-&gt;izquierdo-&gt;frecuencia + n-&gt;derecho-&gt;frecuencia;

        n-&gt;izquierdo-&gt;padre = n;
        n-&gt;izquierdo-&gt;bit = &#x27;0&#x27;;

        n-&gt;derecho-&gt;padre = n;
        n-&gt;derecho-&gt;bit = &#x27;1&#x27;;

        colaDePrioridad.push(n);
    }

    raiz = colaDePrioridad.top();
}</code></pre><p id="5bdf0641-fae5-4d70-ba59-a431688a072c" class="block-color-blue">Codificar</p><pre id="0f00ae41-59e4-4d90-847f-dc1f4a257923" class="code"><code>string Huffman::codificar(const string &amp; mensajeACodificar) const {

    string mensajeCodificado, caracterCodificado;
    Nodo * n;
    for (char caracter : mensajeACodificar) {
        try {
            n = hojas.at(caracter);
        } catch (out_of_range error) {
            throw string(&quot;El mensaje a codificar contiene algun caracter que no estaba &quot;)
                + string(&quot;en la tabla de frecuencias inicial (&quot;) + caracter + &quot;).&quot;;
        }

        caracterCodificado = &quot;&quot;;
        while(n != raiz) {
            caracterCodificado += n-&gt;bit;
            n = n-&gt;padre;
        }
        reverse(caracterCodificado.begin(), caracterCodificado.end());
        mensajeCodificado += caracterCodificado;
    }

    return mensajeCodificado;
}</code></pre><p id="44afd5c1-0896-4cdc-8312-387c357095c7" class="block-color-blue">Decodificar</p><pre id="a4671bed-1d75-4384-86d4-ac20379a6062" class="code"><code>string Huffman::decodificar(const string &amp; mensajeADecodificar) const {

    string mensajeDecodificado;
    Nodo * actual = raiz;
    for (char bitMensaje : mensajeADecodificar) {
        if(bitMensaje == &#x27;0&#x27;)
            actual = actual-&gt;izquierdo;
        else
            actual = actual-&gt;izquierdo;

        if (actual-&gt;izquierdo == nullptr) {
            mensajeDecodificado += actual-&gt;caracter;
            actual = raiz;
        }
    }
    return mensajeDecodificado;
}</code></pre></details></li></ul><h3 id="ff3e3419-d7ce-4ef5-93e2-4ca5d0e06076" class="block-color-blue_background"> TEMA 5</h3><ul id="358fadba-5da0-45a2-a3fa-b35fc7d51a95" class="block-color-gray_background toggle"><li><details open=""><summary>Divide y vencerás (Closest Points)</summary><blockquote id="5f598c08-db50-4fa3-a9cf-d5fc49073901" class=""><a href="http://www3.uji.es/~vjimenez/AULASVIRTUALES/AED-2122/TEMA5.2/ClosestPoints_ayuda.html"> Ayuda V</a>. <a href="https://es.wikipedia.org/wiki/Problema_del_par_de_puntos_m%C3%A1s_cercanos#Algoritmo_recursivo_en_el_plano_2D">Ayuda Wikipedia</a></blockquote><pre id="53cc50d3-4371-4d3b-8de2-b2215487df45" class="code"><code>typedef pair&lt;float, float&gt; Punto;

void ver(const vector&lt;Punto&gt; &amp; puntos) {
    for (const auto &amp; p : puntos)
        cout &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot; )&quot;;
}

bool compararY(const Punto &amp; p1, const Punto &amp; p2) {
    return p1.second &lt; p2.second;
}

float distanciaAlCuadrado(const Punto &amp; p1, const Punto &amp; p2) {
    float a = p2.first - p1.first;
    float b = p2.second - p1.second;
    return a * a + b * b;
}

float distanciaAlCuadradoMinima(const vector&lt;Punto&gt; &amp; puntosPorX, const vector&lt;Punto&gt; &amp; puntosPorY) {
    // Caso base de la recursion
    int talla = puntosPorX.size();
    if (talla == 2)
        return distanciaAlCuadrado(puntosPorX[0], puntosPorX[1]);

    if (talla == 3)
        return min({distanciaAlCuadrado(puntosPorX[0], puntosPorX[1]),
                    distanciaAlCuadrado(puntosPorX[0], puntosPorX[2]),
                    distanciaAlCuadrado(puntosPorX[1], puntosPorX[2])});
    
    // Dividimos los vectores en dos mitades
    int tallaIzquierda = talla / 2;

    vector&lt;Punto&gt; mitadIzqX(puntosPorX.begin(), puntosPorX.begin() + tallaIzquierda);
    vector&lt;Punto&gt; mitadDerX(puntosPorX.begin() + tallaIzquierda, puntosPorX.end());
    
    // Dividimos el vector Y en dos mitades. 
    // O(n) gracias a las mitades ordenadas del vector X
    vector&lt;Punto&gt; mitadIzqY(tallaIzquierda);
    vector&lt;Punto&gt; mitadDerY(talla - tallaIzquierda);

    for (int i = 0, j = 0, k = 0; i &lt; talla; i++)
        if (puntosPorY[i] &lt; mitadDerX[0]) // A igual X mira Y, no pueden coincidir X e Y
            mitadIzqY[j++] = puntosPorY[i];
        else
            mitadDerY[k++] = puntosPorY[i];

    // Llamamos a la funcion recursiva pasandole los puntos de la mitad izquierda
    float minimaIzq = distanciaAlCuadradoMinima(mitadIzqX, mitadIzqY);

    // Llamamos a la funcion recursiva pasandole los puntos de la mitad derecha
    float minimaDer = distanciaAlCuadradoMinima(mitadDerX, mitadDerY); 

    // Creamos un vector con los puntos en la franja central ordenados por Y
    float minima = min(minimaIzq, minimaDer);
    vector&lt;Punto&gt; puntosCentralesPorY;
    float frontera = mitadIzqX[tallaIzquierda - 1].first;
    for (auto punto : puntosPorY)
        if (abs(frontera - punto.first) &lt; minima)
            puntosCentralesPorY.push_back(punto);
   
    // Calculamos distancias entre puntos de la franja central con criterio
    // de parada por distancia vertical
    for (int i = 0; i &lt; puntosCentralesPorY.size() - 1; i++)
        for (int j = i + 1;
            j &lt; puntosCentralesPorY.size() &amp;&amp; puntosCentralesPorY[j].second - puntosCentralesPorY[i].second &lt; minima;
            j++)
            minima = min(minima, distanciaAlCuadrado(puntosCentralesPorY[i], puntosCentralesPorY[j]));
        
    return minima;
}

float distanciaMinima(const vector&lt;Punto&gt; &amp; puntos) {
    // Si tenemos menos de dos puntos paramos
    if (puntos.size() &lt; 2)
        throw string (&quot;Necesitamos al menos dos puntos.&quot;);
    
    // Ordenamos los puntos por X en una copia del vector.
    // Si coinciden se mira la Y
    vector&lt;Punto&gt; ordenadosPorX(puntos);
    sort(ordenadosPorX.begin(), ordenadosPorX.end());

    // Detectamos duplicados
    for (int i = 0; i &lt; ordenadosPorX.size() - 1; i++)
        if (ordenadosPorX[i] == ordenadosPorX[i + 1])
            return 0;    

    // Ordenamos los puntos por Y en una copia del vector
    vector&lt;Punto&gt; ordenadosPorY(puntos);
    sort(ordenadosPorY.begin(), ordenadosPorY.end(), compararY);
    
    // Llamamos a la funcion recursiva pasandole los dos vectores de puntos
    return sqrt(distanciaAlCuadradoMinima(ordenadosPorX, ordenadosPorY));
}</code></pre></details></li></ul><ul id="a3442b0d-d068-4207-9c50-aab1c145a752" class="block-color-gray_background toggle"><li><details open=""><summary>Teorema Maestro (Ejercicio 2 y 8 Divide y vencerás V)</summary></details></li></ul><ul id="7666ae97-e6ad-4157-8881-040974c75fb8" class="block-color-gray_background toggle"><li><details open=""><summary>Programación Dinámica</summary></details></li></ul><h3 id="27141511-29d2-4c50-8123-e44abd6fcd2b" class="block-color-blue_background"> TEMA 6</h3><ul id="f67c2886-c8ad-4b75-9535-9d654fec48c0" class="block-color-gray_background toggle"><li><details open=""><summary>Búsqueda en anchura</summary><p id="99b8f8b8-3707-4448-a987-b2f5ac613458" class="">
</p></details></li></ul><ul id="124e75a7-69a8-423a-aac7-53a6bad589c5" class="block-color-gray_background toggle"><li><details open=""><summary>Búsqueda en profundidad</summary></details></li></ul><ul id="f6237552-7efb-4bda-83ce-94b0d46fe35b" class="block-color-gray_background toggle"><li><details open=""><summary>Dijkstra y Prim</summary></details></li></ul><p id="80419861-0202-42a4-9cfa-a57a179547f2" class="">
</p></div></article></body></html>